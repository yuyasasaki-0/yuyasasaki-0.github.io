"use strict";
(function () {
  var root =
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
  if (!root) return;

  var ns = (root.MailChecker = root.MailChecker || {});

  function canUseOfficeRuntimeStorage() {
    try {
      return (
        typeof OfficeRuntime !== "undefined" &&
        OfficeRuntime &&
        OfficeRuntime.storage &&
        typeof OfficeRuntime.storage.getItem === "function" &&
        typeof OfficeRuntime.storage.setItem === "function"
      );
    } catch (_e) {
      return false;
    }
  }

  function canUseLocalStorage() {
    try {
      return typeof localStorage !== "undefined" && localStorage && typeof localStorage.getItem === "function";
    } catch (_e) {
      return false;
    }
  }

  async function getItem(key) {
    if (!key) return null;

    if (canUseOfficeRuntimeStorage()) {
      try {
        var value = await OfficeRuntime.storage.getItem(String(key));
        return value == null ? null : String(value);
      } catch (_e) {}
    }

    if (canUseLocalStorage()) {
      try {
        var localValue = localStorage.getItem(String(key));
        return localValue == null ? null : String(localValue);
      } catch (_e2) {}
    }

    return null;
  }

  async function setItem(key, value) {
    if (!key) return;
    var stringValue = value == null ? "" : String(value);

    if (canUseOfficeRuntimeStorage()) {
      try {
        await OfficeRuntime.storage.setItem(String(key), stringValue);
        return;
      } catch (_e) {}
    }

    if (canUseLocalStorage()) {
      try {
        localStorage.setItem(String(key), stringValue);
      } catch (_e2) {}
    }
  }

  async function removeItem(key) {
    if (!key) return;

    if (canUseOfficeRuntimeStorage()) {
      try {
        await OfficeRuntime.storage.removeItem(String(key));
      } catch (_e) {}
    }

    if (canUseLocalStorage()) {
      try {
        localStorage.removeItem(String(key));
      } catch (_e2) {}
    }
  }

  async function getJson(key) {
    var raw = await getItem(key);
    if (!raw) return null;
    try {
      return JSON.parse(raw);
    } catch (_e) {
      return null;
    }
  }

  async function setJson(key, obj) {
    try {
      await setItem(key, JSON.stringify(obj == null ? null : obj));
    } catch (_e) {}
  }

  ns.storage = {
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    getJson: getJson,
    setJson: setJson,
    _canUseOfficeRuntimeStorage: canUseOfficeRuntimeStorage,
  };
})();



"use strict";
(function () {
  var root =
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
  if (!root) return;

  var ns = (root.MailChecker = root.MailChecker || {});
  var storage = ns.storage;

  var SETTINGS_KEY = "mailchecker.settings.v1";
  var SCHEMA_VERSION = 1;

  function deepClone(obj) {
    return obj == null ? obj : JSON.parse(JSON.stringify(obj));
  }

  function isObject(value) {
    return value != null && typeof value === "object" && !Array.isArray(value);
  }

  function normalizeString(value) {
    return value == null ? "" : String(value).trim();
  }

  function normalizeBool(value, fallback) {
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value !== 0;
    if (typeof value === "string") {
      var v = value.trim().toLowerCase();
      if (v === "yes" || v === "y" || v === "true" || v === "1") return true;
      if (v === "no" || v === "n" || v === "false" || v === "0") return false;
    }
    return !!fallback;
  }

  function normalizeCcOrBcc(value) {
    var v = normalizeString(value).toLowerCase();
    if (v === "cc") return "Cc";
    if (v === "bcc") return "Bcc";
    return "Bcc";
  }

  function mergeDefaults(target, defaults) {
    if (!isObject(target)) target = {};
    if (!isObject(defaults)) return target;

    Object.keys(defaults).forEach(function (key) {
      var d = defaults[key];
      var t = target[key];
      if (t == null) {
        target[key] = deepClone(d);
        return;
      }
      if (Array.isArray(d)) {
        if (!Array.isArray(t)) target[key] = deepClone(d);
        return;
      }
      if (isObject(d)) {
        target[key] = mergeDefaults(isObject(t) ? t : {}, d);
        return;
      }
    });

    return target;
  }

  function defaultSettings() {
    return {
      schemaVersion: SCHEMA_VERSION,
      general: {
        languageCode: "",
        enableForgottenToAttachAlert: true,
        isDoNotConfirmationIfAllRecipientsAreSameDomain: false,
        isDoDoNotConfirmationIfAllWhite: false,
        isAutoCheckIfAllRecipientsAreSameDomain: false,
        isShowConfirmationToMultipleDomain: false,
        enableGetContactGroupMembers: false,
        enableGetExchangeDistributionListMembers: false,
        contactGroupMembersAreWhite: true,
        exchangeDistributionListMembersAreWhite: true,
        isNotTreatedAsAttachmentsAtHtmlEmbeddedFiles: false,
        isDoNotUseAutoCcBccAttachedFileIfAllRecipientsAreInternalDomain: false,
        isDoNotUseDeferredDeliveryIfAllRecipientsAreInternalDomain: false,
        isDoNotUseAutoCcBccKeywordIfAllRecipientsAreInternalDomain: false,
        isEnableRecipientsAreSortedByDomain: false,
        isAutoAddSenderToBcc: false,
        isAutoAddSenderToCc: false,
        isAutoCheckAttachments: false,
        isCheckNameAndDomainsFromRecipients: false,
        isCheckNameAndDomainsIncludeSubject: false,
        isCheckNameAndDomainsFromSubject: false,
        isCheckKeywordAndRecipientsIncludeSubject: false,
        isAutoCheckRegisteredInContacts: false,
        isAutoCheckRegisteredInContactsAndMemberOfContactLists: false,
        isWarningIfRecipientsIsNotRegistered: false,
        isProhibitsSendingMailIfRecipientsIsNotRegistered: false,
        isShowConfirmationAtSendMeetingRequest: false,
        isShowConfirmationAtSendTaskRequest: false,
      },
      whitelist: [],
      internalDomains: [],
      alertAddresses: [],
      alertKeywordsBody: [],
      alertKeywordsSubject: [],
      autoCcBccKeyword: [],
      autoCcBccRecipient: [],
      autoCcBccAttachedFile: [],
      nameAndDomains: [],
      keywordAndRecipients: [],
      externalDomains: {
        targetToAndCcExternalDomainsNum: 10,
        isWarningWhenLargeNumberOfExternalDomains: true,
        isProhibitedWhenLargeNumberOfExternalDomains: false,
        isAutoChangeToBccWhenLargeNumberOfExternalDomains: false,
      },
      forceAutoChangeRecipientsToBcc: {
        isForceAutoChangeRecipientsToBcc: false,
        toRecipient: "",
        isIncludeInternalDomain: false,
      },
      attachmentsSetting: {
        isWarningWhenEncryptedZipIsAttached: false,
        isProhibitedWhenEncryptedZipIsAttached: false,
        isEnableAllAttachedFilesAreDetectEncryptedZip: false,
        isAttachmentsProhibited: false,
        isWarningWhenAttachedRealFile: false,
        isEnableOpenAttachedFiles: false,
        targetAttachmentFileExtensionOfOpen:
          ".pdf,.txt,.csv,.rtf,.htm,.html,.doc,.docx,.xls,.xlm,.xlsm,.xlsx,.ppt,.pptx,.bmp,.gif,.jpg,.jpeg,.png,.tif,.pub,.vsd,.vsdx",
        isMustOpenBeforeCheckTheAttachedFiles: false,
        isIgnoreMustOpenBeforeCheckTheAttachedFilesIfInternalDomain: false,
      },
      recipientsAndAttachmentsName: [],
      attachmentProhibitedRecipients: [],
      attachmentAlertRecipients: [],
      autoDeleteRecipients: [],
      autoAddMessage: {
        isAddToStart: false,
        isAddToEnd: false,
        messageOfAddToStart: "",
        messageOfAddToEnd: "",
      },
      securityForReceivedMail: {
        isEnableSecurityForReceivedMail: false,
        isEnableAlertKeywordOfSubjectWhenOpeningMailsData: false,
        isEnableMailHeaderAnalysis: false,
        isShowWarningWhenSpfFails: false,
        isShowWarningWhenDkimFails: false,
        isEnableWarningFeatureWhenOpeningAttachments: false,
        isWarnBeforeOpeningAttachments: false,
        isWarnBeforeOpeningEncryptedZip: false,
        isWarnLinkFileInTheZip: false,
        isWarnOneFileInTheZip: false,
        isWarnOfficeFileWithMacroInTheZip: false,
        isWarnBeforeOpeningAttachmentsThatContainMacros: false,
        isShowWarningWhenSpoofingRisk: false,
        isShowWarningWhenDmarcNotImplemented: false,
      },
      alertKeywordOfSubjectWhenOpeningMail: [],

      // New add-in specific knobs (no CSV equivalent)
      runtime: {
        largeAttachmentBytes: 10485760, // 10MB (same as OutlookOkan)
        sendEventTimeoutMs: 4500,
      },
    };
  }

  function normalizeWhitelist(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var whiteName = normalizeString(row.whiteName != null ? row.whiteName : row.WhiteName);
      if (!whiteName) continue;
      out.push({
        whiteName: whiteName,
        isSkipConfirmation: normalizeBool(
          row.isSkipConfirmation != null ? row.isSkipConfirmation : row.IsSkipConfirmation,
          false
        ),
      });
    }
    return out;
  }

  function normalizeInternalDomains(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var domain = normalizeString(row.domain != null ? row.domain : row.Domain);
      if (!domain) continue;
      out.push({ domain: domain });
    }
    return out;
  }

  function normalizeAlertAddresses(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var targetAddress = normalizeString(row.targetAddress != null ? row.targetAddress : row.TargetAddress);
      if (!targetAddress) continue;
      out.push({
        targetAddress: targetAddress,
        isCanNotSend: normalizeBool(row.isCanNotSend != null ? row.isCanNotSend : row.IsCanNotSend, false),
        message: normalizeString(row.message != null ? row.message : row.Message),
      });
    }
    return out;
  }

  function normalizeAlertKeywords(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var alertKeyword = normalizeString(row.alertKeyword != null ? row.alertKeyword : row.AlertKeyword);
      if (!alertKeyword) continue;
      out.push({
        alertKeyword: alertKeyword,
        message: normalizeString(row.message != null ? row.message : row.Message),
        isCanNotSend: normalizeBool(row.isCanNotSend != null ? row.isCanNotSend : row.IsCanNotSend, false),
      });
    }
    return out;
  }

  function normalizeAutoCcBccKeyword(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var keyword = normalizeString(row.keyword != null ? row.keyword : row.Keyword);
      var autoAddAddress = normalizeString(row.autoAddAddress != null ? row.autoAddAddress : row.AutoAddAddress);
      if (!keyword || !autoAddAddress) continue;
      out.push({
        keyword: keyword,
        ccOrBcc: normalizeCcOrBcc(row.ccOrBcc != null ? row.ccOrBcc : row.CcOrBcc),
        autoAddAddress: autoAddAddress,
      });
    }
    return out;
  }

  function normalizeAutoCcBccRecipient(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var targetRecipient = normalizeString(row.targetRecipient != null ? row.targetRecipient : row.TargetRecipient);
      var autoAddAddress = normalizeString(row.autoAddAddress != null ? row.autoAddAddress : row.AutoAddAddress);
      if (!targetRecipient || !autoAddAddress) continue;
      out.push({
        targetRecipient: targetRecipient,
        ccOrBcc: normalizeCcOrBcc(row.ccOrBcc != null ? row.ccOrBcc : row.CcOrBcc),
        autoAddAddress: autoAddAddress,
      });
    }
    return out;
  }

  function normalizeAutoCcBccAttachedFile(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var autoAddAddress = normalizeString(row.autoAddAddress != null ? row.autoAddAddress : row.AutoAddAddress);
      if (!autoAddAddress) continue;
      out.push({
        ccOrBcc: normalizeCcOrBcc(row.ccOrBcc != null ? row.ccOrBcc : row.CcOrBcc),
        autoAddAddress: autoAddAddress,
      });
    }
    return out;
  }

  function normalizeNameAndDomains(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var name = normalizeString(row.name != null ? row.name : row.Name);
      var domain = normalizeString(row.domain != null ? row.domain : row.Domain);
      if (!name || !domain) continue;
      out.push({ name: name, domain: domain });
    }
    return out;
  }

  function normalizeKeywordAndRecipients(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var keyword = normalizeString(row.keyword != null ? row.keyword : row.Keyword);
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!keyword || !recipient) continue;
      out.push({ keyword: keyword, recipient: recipient });
    }
    return out;
  }

  function normalizeRecipientsAndAttachmentsName(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var attachmentsName = normalizeString(
        row.attachmentsName != null ? row.attachmentsName : row.AttachmentsName
      );
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!attachmentsName || !recipient) continue;
      out.push({ attachmentsName: attachmentsName, recipient: recipient });
    }
    return out;
  }

  function normalizeAttachmentProhibitedRecipients(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!recipient) continue;
      out.push({ recipient: recipient });
    }
    return out;
  }

  function normalizeAttachmentAlertRecipients(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!recipient) continue;
      out.push({
        recipient: recipient,
        message: normalizeString(row.message != null ? row.message : row.Message),
      });
    }
    return out;
  }

  function normalizeAutoDeleteRecipients(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!recipient) continue;
      out.push({ recipient: recipient });
    }
    return out;
  }

  function normalizeAlertKeywordOfSubjectWhenOpeningMail(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!isObject(row)) continue;
      var alertKeyword = normalizeString(row.alertKeyword != null ? row.alertKeyword : row.AlertKeyword);
      if (!alertKeyword) continue;
      out.push({
        alertKeyword: alertKeyword,
        message: normalizeString(row.message != null ? row.message : row.Message),
      });
    }
    return out;
  }

  function normalizeSettings(settings) {
    var defaults = defaultSettings();
    var merged = mergeDefaults(isObject(settings) ? settings : {}, defaults);

    merged.schemaVersion = SCHEMA_VERSION;

    merged.whitelist = normalizeWhitelist(merged.whitelist);
    merged.internalDomains = normalizeInternalDomains(merged.internalDomains);
    merged.alertAddresses = normalizeAlertAddresses(merged.alertAddresses);
    merged.alertKeywordsBody = normalizeAlertKeywords(merged.alertKeywordsBody);
    merged.alertKeywordsSubject = normalizeAlertKeywords(merged.alertKeywordsSubject);
    merged.autoCcBccKeyword = normalizeAutoCcBccKeyword(merged.autoCcBccKeyword);
    merged.autoCcBccRecipient = normalizeAutoCcBccRecipient(merged.autoCcBccRecipient);
    merged.autoCcBccAttachedFile = normalizeAutoCcBccAttachedFile(merged.autoCcBccAttachedFile);
    merged.nameAndDomains = normalizeNameAndDomains(merged.nameAndDomains);
    merged.keywordAndRecipients = normalizeKeywordAndRecipients(merged.keywordAndRecipients);
    merged.recipientsAndAttachmentsName = normalizeRecipientsAndAttachmentsName(merged.recipientsAndAttachmentsName);
    merged.attachmentProhibitedRecipients = normalizeAttachmentProhibitedRecipients(merged.attachmentProhibitedRecipients);
    merged.attachmentAlertRecipients = normalizeAttachmentAlertRecipients(merged.attachmentAlertRecipients);
    merged.autoDeleteRecipients = normalizeAutoDeleteRecipients(merged.autoDeleteRecipients);
    merged.alertKeywordOfSubjectWhenOpeningMail = normalizeAlertKeywordOfSubjectWhenOpeningMail(
      merged.alertKeywordOfSubjectWhenOpeningMail
    );

    return merged;
  }

  async function loadSettings() {
    if (!storage) return normalizeSettings(null);
    var data = await storage.getJson(SETTINGS_KEY);
    return normalizeSettings(data);
  }

  async function saveSettings(settings) {
    if (!storage) return;
    await storage.setJson(SETTINGS_KEY, normalizeSettings(settings));
  }

  async function resetSettings() {
    if (!storage) return;
    await storage.removeItem(SETTINGS_KEY);
  }

  ns.settings = {
    KEY: SETTINGS_KEY,
    SCHEMA_VERSION: SCHEMA_VERSION,
    defaults: defaultSettings,
    load: loadSettings,
    save: saveSettings,
    reset: resetSettings,
    _normalize: normalizeSettings,
  };
})();


"use strict";
(function () {
  var root =
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
  if (!root) return;

  var ns = (root.MailChecker = root.MailChecker || {});
  var storage = ns.storage;

  function normalizeString(value) {
    return value == null ? "" : String(value).trim();
  }

  function lower(value) {
    return value == null ? "" : String(value).toLowerCase();
  }

  function withTimeout(promise, ms, timeoutValue) {
    return new Promise(function (resolve) {
      var done = false;
      var id = null;

      try {
        if (typeof ms === "number" && isFinite(ms) && ms > 0) {
          id = setTimeout(function () {
            if (done) return;
            done = true;
            resolve(timeoutValue);
          }, ms);
        }
      } catch (_e) {}

      Promise.resolve(promise)
        .then(function (value) {
          if (done) return;
          done = true;
          try {
            if (id != null) clearTimeout(id);
          } catch (_e2) {}
          resolve(value);
        })
        .catch(function (_err) {
          if (done) return;
          done = true;
          try {
            if (id != null) clearTimeout(id);
          } catch (_e3) {}
          resolve(timeoutValue);
        });
    });
  }

  function canUseEws() {
    try {
      return (
        typeof Office !== "undefined" &&
        Office &&
        Office.context &&
        Office.context.mailbox &&
        typeof Office.context.mailbox.makeEwsRequestAsync === "function"
      );
    } catch (_e) {
      return false;
    }
  }

  function pMakeEwsRequest(requestXml) {
    return new Promise(function (resolve) {
      try {
        if (!canUseEws()) return resolve({ ok: false, error: "EWS is not available in this client." });
        var mailbox = Office.context.mailbox;
        mailbox.makeEwsRequestAsync(String(requestXml || ""), function (asyncResult) {
          try {
            if (!asyncResult || asyncResult.status !== Office.AsyncResultStatus.Succeeded) {
              var msg = "";
              try {
                msg = asyncResult && asyncResult.error && asyncResult.error.message ? asyncResult.error.message : "";
              } catch (_e2) {}
              return resolve({ ok: false, error: msg || "EWS request failed." });
            }
            resolve({ ok: true, value: String(asyncResult.value || "") });
          } catch (_e3) {
            resolve({ ok: false, error: "EWS request failed." });
          }
        });
      } catch (_e) {
        resolve({ ok: false, error: "EWS request failed." });
      }
    });
  }

  function parseXml(xmlText) {
    try {
      if (!xmlText) return null;
      var doc = new DOMParser().parseFromString(String(xmlText), "text/xml");
      return doc;
    } catch (_e) {
      return null;
    }
  }

  function findFirstByLocalName(rootNode, localName) {
    if (!rootNode) return null;
    try {
      var all = rootNode.getElementsByTagName("*");
      for (var i = 0; i < all.length; i++) {
        if (all[i] && all[i].localName === localName) return all[i];
      }
    } catch (_e) {}
    return null;
  }

  function findAllByLocalName(rootNode, localName) {
    var out = [];
    if (!rootNode) return out;
    try {
      var all = rootNode.getElementsByTagName("*");
      for (var i = 0; i < all.length; i++) {
        if (all[i] && all[i].localName === localName) out.push(all[i]);
      }
    } catch (_e) {}
    return out;
  }

  function textContent(node) {
    try {
      return node && node.textContent != null ? String(node.textContent) : "";
    } catch (_e) {
      return "";
    }
  }

  function getEwsResponseCode(doc) {
    if (!doc) return "";
    var node = findFirstByLocalName(doc, "ResponseCode");
    return normalizeString(textContent(node));
  }

  function getEwsResponseClass(doc) {
    if (!doc) return "";
    var msg = findFirstByLocalName(doc, "ResponseMessage");
    try {
      if (!msg || !msg.getAttribute) return "";
      return normalizeString(msg.getAttribute("ResponseClass"));
    } catch (_e) {
      return "";
    }
  }

  function extractEwsMessageText(doc) {
    if (!doc) return "";
    var msgText = findFirstByLocalName(doc, "MessageText");
    return normalizeString(textContent(msgText));
  }

  function isEwsSuccess(doc) {
    var rc = lower(getEwsResponseClass(doc));
    if (rc === "success") return true;
    var code = lower(getEwsResponseCode(doc));
    if (code === "noerror") return true;
    return false;
  }

  function buildSoapEnvelope(bodyInnerXml) {
    return (
      '<?xml version="1.0" encoding="utf-8"?>' +
      '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
      'xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages" ' +
      'xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types" ' +
      'xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">' +
      "<soap:Header>" +
      '<t:RequestServerVersion Version="Exchange2013" />' +
      "</soap:Header>" +
      "<soap:Body>" +
      String(bodyInnerXml || "") +
      "</soap:Body>" +
      "</soap:Envelope>"
    );
  }

  function buildExpandDlRequest(emailAddress) {
    var email = normalizeString(emailAddress);
    return buildSoapEnvelope(
      "<m:ExpandDL>" +
        "<m:Mailbox>" +
        "<t:EmailAddress>" +
        escapeXml(email) +
        "</t:EmailAddress>" +
        "</m:Mailbox>" +
        "</m:ExpandDL>"
    );
  }

  function buildResolveNamesRequest(unresolvedEntry, searchScope) {
    var entry = normalizeString(unresolvedEntry);
    var scope = normalizeString(searchScope) || "Contacts";
    return buildSoapEnvelope(
      '<m:ResolveNames ReturnFullContactData="true" SearchScope="' +
        escapeXmlAttribute(scope) +
        '">' +
        "<m:UnresolvedEntry>" +
        escapeXml(entry) +
        "</m:UnresolvedEntry>" +
        "</m:ResolveNames>"
    );
  }

  function escapeXml(text) {
    return String(text || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }

  function escapeXmlAttribute(text) {
    return escapeXml(text).replace(/\r?\n/g, " ");
  }

  function parseDlExpansion(doc) {
    var out = [];
    if (!doc) return out;
    var dl = findFirstByLocalName(doc, "DLExpansion");
    if (!dl) return out;

    var mailboxes = findAllByLocalName(dl, "Mailbox");
    for (var i = 0; i < mailboxes.length; i++) {
      var mb = mailboxes[i];
      if (!mb) continue;
      var name = normalizeString(textContent(findFirstByLocalName(mb, "Name")));
      var email = normalizeString(textContent(findFirstByLocalName(mb, "EmailAddress")));
      var mailboxType = normalizeString(textContent(findFirstByLocalName(mb, "MailboxType")));
      if (!email) continue;
      out.push({ emailAddress: email, displayName: name, mailboxType: mailboxType });
    }

    return out;
  }

  function parseResolveNames(doc) {
    if (!doc) return { resolutions: [] };
    var rs = findFirstByLocalName(doc, "ResolutionSet");
    if (!rs) return { resolutions: [] };

    var resolutions = [];
    var resNodes = findAllByLocalName(rs, "Resolution");
    for (var i = 0; i < resNodes.length; i++) {
      var res = resNodes[i];
      if (!res) continue;

      var mailbox = findFirstByLocalName(res, "Mailbox");
      var name = normalizeString(textContent(findFirstByLocalName(mailbox, "Name")));
      var email = normalizeString(textContent(findFirstByLocalName(mailbox, "EmailAddress")));
      var mailboxType = normalizeString(textContent(findFirstByLocalName(mailbox, "MailboxType")));

      resolutions.push({ emailAddress: email, displayName: name, mailboxType: mailboxType });
    }

    return { resolutions: resolutions };
  }

  var CONTACTS_CACHE_KEY = "mailchecker.cache.contacts.v1";
  var DL_CACHE_KEY = "mailchecker.cache.dl.v1";

  function nowMs() {
    try {
      return Date.now();
    } catch (_e) {
      return 0;
    }
  }

  async function getCacheDoc(key) {
    if (!storage || typeof storage.getJson !== "function") return { schemaVersion: 1, entries: {} };
    var doc = null;
    try {
      doc = await storage.getJson(key);
    } catch (_e) {
      doc = null;
    }
    if (!doc || typeof doc !== "object") return { schemaVersion: 1, entries: {} };
    if (!doc.entries || typeof doc.entries !== "object") doc.entries = {};
    return doc;
  }

  async function setCacheDoc(key, doc) {
    if (!storage || typeof storage.setJson !== "function") return;
    try {
      await storage.setJson(key, doc || null);
    } catch (_e) {}
  }

  function isFresh(entry, ttlMs) {
    if (!entry || typeof entry !== "object") return false;
    if (typeof entry.ts !== "number") return false;
    if (ttlMs <= 0) return false;
    return nowMs() - entry.ts < ttlMs;
  }

  async function expandDlCached(emailAddress, options) {
    var email = normalizeString(emailAddress);
    if (!email) return { ok: false, members: [], error: "Missing email address." };

    var ttlMs = 24 * 60 * 60 * 1000; // 1 day
    var timeoutMs = 1200;
    try {
      if (options && typeof options.ttlMs === "number") ttlMs = options.ttlMs;
      if (options && typeof options.timeoutMs === "number") timeoutMs = options.timeoutMs;
    } catch (_e) {}

    var key = lower(email);
    var doc = await getCacheDoc(DL_CACHE_KEY);
    var cached = doc.entries[key];
    if (isFresh(cached, ttlMs) && Array.isArray(cached.members)) {
      return { ok: true, members: cached.members, cached: true };
    }

    var requestXml = buildExpandDlRequest(email);
    var response = await withTimeout(pMakeEwsRequest(requestXml), timeoutMs, { ok: false, error: "Timeout" });
    if (!response || !response.ok) {
      return { ok: false, members: [], error: (response && response.error) || "EWS failed." };
    }

    var docXml = parseXml(response.value);
    if (!docXml) return { ok: false, members: [], error: "Failed to parse EWS response." };
    if (!isEwsSuccess(docXml)) {
      return {
        ok: false,
        members: [],
        error: getEwsResponseCode(docXml) || extractEwsMessageText(docXml) || "EWS error.",
      };
    }

    var members = parseDlExpansion(docXml);
    doc.entries[key] = { ts: nowMs(), members: members };
    await setCacheDoc(DL_CACHE_KEY, doc);
    return { ok: true, members: members, cached: false };
  }

  async function resolveInContactsCached(emailAddress, options) {
    var email = normalizeString(emailAddress);
    if (!email) return { ok: false, value: null, error: "Missing email address." };

    var ttlMs = 7 * 24 * 60 * 60 * 1000; // 7 days
    var timeoutMs = 900;
    try {
      if (options && typeof options.ttlMs === "number") ttlMs = options.ttlMs;
      if (options && typeof options.timeoutMs === "number") timeoutMs = options.timeoutMs;
    } catch (_e) {}

    var key = lower(email);
    var doc = await getCacheDoc(CONTACTS_CACHE_KEY);
    var cached = doc.entries[key];
    if (isFresh(cached, ttlMs) && typeof cached.value === "boolean") {
      return { ok: true, value: cached.value, cached: true };
    }

    var requestXml = buildResolveNamesRequest(email, "Contacts");
    var response = await withTimeout(pMakeEwsRequest(requestXml), timeoutMs, { ok: false, error: "Timeout" });
    if (!response || !response.ok) {
      return { ok: false, value: null, error: (response && response.error) || "EWS failed." };
    }

    var docXml = parseXml(response.value);
    if (!docXml) return { ok: false, value: null, error: "Failed to parse EWS response." };
    if (!isEwsSuccess(docXml)) {
      return {
        ok: false,
        value: null,
        error: getEwsResponseCode(docXml) || extractEwsMessageText(docXml) || "EWS error.",
      };
    }

    var parsed = parseResolveNames(docXml);
    var found = Array.isArray(parsed.resolutions) && parsed.resolutions.length > 0;
    doc.entries[key] = { ts: nowMs(), value: found };
    await setCacheDoc(CONTACTS_CACHE_KEY, doc);
    return { ok: true, value: found, cached: false };
  }

  ns.ews = {
    canUseEws: canUseEws,
    _pMakeEwsRequest: pMakeEwsRequest,
    expandDlCached: expandDlCached,
    resolveInContactsCached: resolveInContactsCached,
  };
})();



"use strict";
(function () {
  var root =
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
  if (!root) return;

  var ns = (root.MailChecker = root.MailChecker || {});

  function isObject(value) {
    return value != null && typeof value === "object" && !Array.isArray(value);
  }

  function normalizeString(value) {
    return value == null ? "" : String(value).trim();
  }

  function lower(value) {
    return value == null ? "" : String(value).toLowerCase();
  }

  function startsWith(value, prefix) {
    return String(value || "").slice(0, String(prefix || "").length) === String(prefix || "");
  }

  function endsWith(value, suffix) {
    var s = String(value || "");
    var suf = String(suffix || "");
    if (!suf) return false;
    return s.slice(s.length - suf.length) === suf;
  }

  function uniq(list) {
    if (!Array.isArray(list)) return [];
    var seen = {};
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var v = String(list[i] || "");
      if (!v) continue;
      var key = lower(v);
      if (seen[key]) continue;
      seen[key] = true;
      out.push(v);
    }
    return out;
  }

  function domainSuffixFromAddress(address) {
    var a = normalizeString(address);
    if (!a) return "";
    var at = a.lastIndexOf("@");
    if (at < 0) return "";
    return lower(a.slice(at)); // includes "@"
  }

  function normalizeDomainSuffix(value) {
    var v = lower(normalizeString(value));
    if (!v) return "";
    if (v.indexOf("@") === 0) return v;
    if (v.indexOf("@") >= 0) return v.slice(v.lastIndexOf("@"));
    return "@" + v;
  }

  function addressMatchesTarget(address, targetAddressOrDomain) {
    var a = lower(normalizeString(address));
    var t = lower(normalizeString(targetAddressOrDomain));
    if (!a || !t) return false;

    // OutlookOkan semantics are mostly "EndsWith" and sometimes "Equals".
    if (a === t) return true;
    if (endsWith(a, t)) return true;

    // If target is a domain without '@', match domain suffix too.
    if (t.indexOf("@") < 0) {
      var dom = normalizeDomainSuffix(t);
      if (dom && endsWith(a, dom)) return true;
    }

    return false;
  }

  function isInternalAddress(address, internalDomainList) {
    var a = lower(normalizeString(address));
    if (!a) return false;
    for (var i = 0; i < internalDomainList.length; i++) {
      var suf = internalDomainList[i];
      if (!suf) continue;
      if (endsWith(a, suf)) return true;
    }
    return false;
  }

  function isWhitelisted(address, whitelist) {
    var a = lower(normalizeString(address));
    if (!a || !Array.isArray(whitelist) || whitelist.length === 0) return false;
    for (var i = 0; i < whitelist.length; i++) {
      var w = whitelist[i];
      if (!w || !w.whiteName) continue;
      var name = lower(normalizeString(w.whiteName));
      if (!name) continue;
      if (a === name) return true;
      if (endsWith(a, name)) return true;
    }
    return false;
  }

  function isSkipConfirmation(address, whitelist) {
    var a = lower(normalizeString(address));
    if (!a || !Array.isArray(whitelist) || whitelist.length === 0) return false;
    for (var i = 0; i < whitelist.length; i++) {
      var w = whitelist[i];
      if (!w || !w.whiteName) continue;
      var name = lower(normalizeString(w.whiteName));
      if (!name) continue;
      if (a.indexOf(name) >= 0) return !!w.isSkipConfirmation;
    }
    return false;
  }

  function formatRecipient(displayName, emailAddress) {
    var dn = normalizeString(displayName);
    var ea = normalizeString(emailAddress);
    if (!dn) return ea || "";
    if (!ea) return dn;
    if (lower(dn) === lower(ea)) return ea;
    return dn + " <" + ea + ">";
  }

  function normalizeRecipients(list) {
    if (!Array.isArray(list)) return [];
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var r = list[i];
      if (!r) continue;
      var email = normalizeString(r.emailAddress != null ? r.emailAddress : r.address);
      var displayName = normalizeString(r.displayName != null ? r.displayName : r.name);
      var key = lower(email);
      if (!key) continue;
      out.push({
        emailAddress: email,
        displayName: displayName,
        key: key,
        formatted: formatRecipient(displayName, email),
      });
    }
    return out;
  }

  function dedupeRecipients(to, cc, bcc) {
    function filter(list) {
      var seen = {};
      var out = [];
      for (var i = 0; i < list.length; i++) {
        var r = list[i];
        if (!r || !r.key) continue;
        if (seen[r.key]) continue;
        seen[r.key] = true;
        out.push(r);
      }
      return out;
    }

    return {
      to: filter(to),
      cc: filter(cc),
      bcc: filter(bcc),
    };
  }

  function dedupeRecipientList(list) {
    if (!Array.isArray(list)) return [];
    var seen = {};
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var r = list[i];
      if (!r || !r.key) continue;
      if (seen[r.key]) continue;
      seen[r.key] = true;
      out.push(r);
    }
    return out;
  }

  function normalizeExpandedGroups(snapshot, recipientsActual) {
    var resolved = snapshot && snapshot.resolved;
    var groups = [];
    try {
      groups = Array.isArray(resolved && resolved.expandedGroups)
        ? resolved.expandedGroups
        : Array.isArray(resolved && resolved.groups)
          ? resolved.groups
          : [];
    } catch (_e) {
      groups = [];
    }

    var out = { to: [], cc: [], bcc: [], all: [], errors: [] };
    if (!groups || groups.length === 0) return out;

    var present = {};
    try {
      if (recipientsActual) {
        var all = []
          .concat(recipientsActual.to || [])
          .concat(recipientsActual.cc || [])
          .concat(recipientsActual.bcc || []);
        for (var i = 0; i < all.length; i++) {
          if (all[i] && all[i].key) present[all[i].key] = true;
        }
      }
    } catch (_e2) {}

    var seenByField = {
      to: {},
      cc: {},
      bcc: {},
    };
    var seenAll = {};

    function normalizeMembers(list) {
      if (!Array.isArray(list)) return [];
      var temp = [];
      for (var i = 0; i < list.length; i++) {
        var m = list[i];
        if (!m) continue;
        if (typeof m === "string") temp.push({ emailAddress: m, displayName: "" });
        else temp.push(m);
      }
      return normalizeRecipients(temp);
    }

    for (var g = 0; g < groups.length; g++) {
      var group = groups[g];
      if (!group) continue;

      var groupEmail = normalizeString(group.emailAddress != null ? group.emailAddress : group.address);
      var groupKey = lower(groupEmail);
      if (groupKey && Object.keys(present).length > 0 && !present[groupKey]) continue;

      var label = normalizeString(group.displayName) || groupEmail;
      var field = lower(normalizeString(group.field != null ? group.field : group.type));
      var outField = field === "cc" ? "cc" : field === "bcc" ? "bcc" : "to";
      var fieldSeen = seenByField[outField];

      var members = [];
      try {
        members = normalizeMembers(group.members || group.Members || []);
      } catch (_e3) {
        members = [];
      }

      for (var m2 = 0; m2 < members.length; m2++) {
        var mem = members[m2];
        if (!mem || !mem.key) continue;
        var memberForField = mem;
        if (!fieldSeen[mem.key]) {
          fieldSeen[mem.key] = true;
          memberForField = {
            emailAddress: mem.emailAddress,
            displayName: mem.displayName,
            key: mem.key,
            formatted: mem.formatted,
          };

          if (label) {
            memberForField.expandedFrom = label;
            memberForField.formatted = memberForField.formatted + " [" + label + "]";
          }

          if (outField === "cc") out.cc.push(memberForField);
          else if (outField === "bcc") out.bcc.push(memberForField);
          else out.to.push(memberForField);
        }

        if (!seenAll[mem.key]) {
          seenAll[mem.key] = true;
          out.all.push({
            emailAddress: mem.emailAddress,
            displayName: mem.displayName,
            key: mem.key,
            formatted: mem.formatted,
          });
        }
      }
    }

    return out;
  }

  function toEmailList(list) {
    var out = [];
    for (var i = 0; i < list.length; i++) {
      var r = list[i];
      if (!r || !r.emailAddress) continue;
      out.push(r.emailAddress);
    }
    return out;
  }

  function attachmentFileType(fileName) {
    var name = normalizeString(fileName);
    if (!name) return "";
    var dot = name.lastIndexOf(".");
    if (dot < 0) return "";
    return lower(name.slice(dot));
  }

  function formatBytes(bytes) {
    if (typeof bytes !== "number" || !isFinite(bytes) || bytes < 0) return "?";
    var kb = bytes / 1024;
    if (kb < 1024) return Math.round(kb) + "KB";
    var mb = kb / 1024;
    if (mb < 1024) return (Math.round(mb * 10) / 10).toFixed(1) + "MB";
    var gb = mb / 1024;
    return (Math.round(gb * 10) / 10).toFixed(1) + "GB";
  }

  function countRecipientExternalDomains(recipients, senderDomainSuffix, internalDomains, isToAndCcOnly) {
    var domainMap = {};
    var domains = [];

    function addDomain(address) {
      if (!address) return;
      var suf = domainSuffixFromAddress(address);
      if (!suf) return;
      if (domainMap[suf]) return;
      domainMap[suf] = true;
      domains.push(suf);
    }

    if (isToAndCcOnly) {
      for (var i = 0; i < recipients.to.length; i++) addDomain(recipients.to[i].emailAddress);
      for (var j = 0; j < recipients.cc.length; j++) addDomain(recipients.cc[j].emailAddress);
    } else {
      for (var k = 0; k < recipients.to.length; k++) addDomain(recipients.to[k].emailAddress);
      for (var l = 0; l < recipients.cc.length; l++) addDomain(recipients.cc[l].emailAddress);
      for (var m = 0; m < recipients.bcc.length; m++) addDomain(recipients.bcc[m].emailAddress);
    }

    var externalCount = domains.length;
    for (var x = 0; x < internalDomains.length; x++) {
      var internal = internalDomains[x];
      if (!internal) continue;
      var anyMatch = false;
      for (var y = 0; y < domains.length; y++) {
        if (endsWith(domains[y], internal)) {
          anyMatch = true;
          break;
        }
      }
      if (anyMatch && !endsWith(senderDomainSuffix, internal)) {
        externalCount--;
      }
    }

    if (domainMap[senderDomainSuffix]) externalCount--;
    return externalCount;
  }

  function isAllRecipientsInternal(checkList) {
    function allInternal(list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].isExternal) return false;
      }
      return true;
    }
    return (
      allInternal(checkList.toAddresses) &&
      allInternal(checkList.ccAddresses) &&
      allInternal(checkList.bccAddresses)
    );
  }

  function isAllRecipientsSkip(checkList) {
    function allSkip(list) {
      if (list.length === 0) return true;
      for (var i = 0; i < list.length; i++) {
        if (!list[i].isSkip) return false;
      }
      return true;
    }
    return allSkip(checkList.toAddresses) && allSkip(checkList.ccAddresses) && allSkip(checkList.bccAddresses);
  }

  function isAllChecked(checkList) {
    function allChecked(list) {
      for (var i = 0; i < list.length; i++) {
        if (!list[i].isChecked) return false;
      }
      return true;
    }

    return (
      allChecked(checkList.toAddresses) &&
      allChecked(checkList.ccAddresses) &&
      allChecked(checkList.bccAddresses) &&
      allChecked(checkList.alerts) &&
      allChecked(checkList.attachments)
    );
  }

  function computeShowConfirmation(checkList, settingsGeneral) {
    var g = settingsGeneral || {};

    if (checkList.recipientExternalDomainNumAll >= 2 && !!g.isShowConfirmationToMultipleDomain) return true;
    if (!!g.isDoNotConfirmationIfAllRecipientsAreSameDomain && isAllRecipientsInternal(checkList)) return false;
    if (isAllRecipientsSkip(checkList)) return false;
    if (!!g.isDoDoNotConfirmationIfAllWhite && isAllChecked(checkList)) return false;
    return true;
  }

  function pushAlert(checkList, alertMessage, isImportant, isWhite, isChecked) {
    checkList.alerts.push({
      alertMessage: String(alertMessage || ""),
      isImportant: !!isImportant,
      isWhite: !!isWhite,
      isChecked: !!isChecked,
    });
  }

  function t(locale, key) {
    var ja = startsWith(locale, "ja");
    switch (key) {
      case "forbid":
        return ja ? "送信禁止" : "Send blocked";
      case "forgotAttach":
        return ja ? "添付ファイルの添付漏れの可能性があります。" : "Possible missing attachment.";
      case "largeAttachment":
        return ja ? "大容量の添付ファイルです" : "Large attachment";
      case "dangerousExe":
        return ja ? "実行ファイル(.exe)が添付されています" : "Executable (.exe) attached";
      case "encryptedZip":
        return ja ? "暗号化ZIP(パスワード付きZIP)の可能性があります" : "Possible encrypted ZIP (password-protected ZIP)";
      case "attachmentsProhibited":
        return ja ? "添付ファイル付きメールの送信は禁止されています。" : "Sending with attachments is prohibited.";
      case "attachmentProhibitedRecipients":
        return ja ? "添付ファイル送付禁止の宛先が含まれます" : "Attachments prohibited for recipients";
      case "attachmentAlertRecipients":
        return ja ? "添付ファイル付きメールの宛先に注意してください" : "Caution: attachments with these recipients";
      case "recipientsAndAttachmentsName":
        return ja ? "添付ファイル名と宛先の紐づけに一致しません" : "Attachment name / recipient mapping mismatch";
      case "recommendLink":
        return ja ? "可能であればリンクとして添付することを推奨します。" : "Consider attaching as a link instead of a file.";
      case "keywordAndRecipients":
        return ja ? "本文/件名にキーワードがあるのに宛先が含まれません" : "Keyword present but required recipient missing";
      case "nameDomainMissingInBody":
        return ja ? "本文に紐づく名称が見つかりません" : "Linked name not found in body";
      case "nameDomainMissingInSubject":
        return ja ? "件名に紐づく名称が見つかりません" : "Linked name not found in subject";
      case "maybeIrrelevantRecipient":
        return ja ? "本文(件名)の名称と宛先が一致しない可能性があります" : "Recipients may not match names in content";
      case "externalDomainWarning":
        return ja ? "宛先(To/Cc)の外部ドメイン数が多いです" : "Many external domains in To/Cc";
      case "externalDomainProhibited":
        return ja ? "宛先(To/Cc)の外部ドメイン数が多いため送信禁止です" : "Send blocked: too many external domains in To/Cc";
      case "externalToBccChanged":
        return ja ? "外部宛先(To/Cc)をBccへ自動変換しました" : "Converted external To/Cc recipients to Bcc";
      case "forceToBccChanged":
        return ja ? "宛先を強制的にBccへ変換しました" : "Forced recipients to Bcc";
      case "autoAddSenderToTo":
        return ja ? "Toが空のため送信者をToへ追加しました" : "Added sender to To (To was empty)";
      case "removedRecipients":
        return ja ? "設定により宛先を削除しました" : "Removed recipients by rule";
      case "contactsNotRegisteredWarning":
        return ja ? "連絡先(アドレス帳)未登録の宛先です" : "Recipient not found in Contacts";
      case "contactsNotRegisteredProhibit":
        return ja ? "連絡先(アドレス帳)未登録の宛先があるため送信禁止です" : "Send blocked: recipient not found in Contacts";
      case "contactsLookupUnavailable":
        return ja ? "連絡先(アドレス帳)の確認ができませんでした" : "Couldn't verify recipients in Contacts";
      case "contactsLookupIncomplete":
        return ja ? "連絡先(アドレス帳)の確認が未完了です" : "Contacts verification incomplete";
      case "allRecipientsRemoved":
        return ja ? "宛先がすべて削除されたため送信できません。" : "All recipients were removed; cannot send.";
      case "autoAddedRecipient":
        return ja ? "宛先を自動追加しました" : "Auto-added recipient";
      case "addedTextStart":
        return ja ? "本文の先頭に文言を自動追加します" : "Will prepend text to body";
      case "addedTextEnd":
        return ja ? "本文の末尾に文言を自動追加します" : "Will append text to body";
      default:
        return key;
    }
  }

  function buildInternalDomains(settings, senderDomainSuffix) {
    var list = [];
    if (settings && Array.isArray(settings.internalDomains)) {
      for (var i = 0; i < settings.internalDomains.length; i++) {
        var row = settings.internalDomains[i];
        if (!row) continue;
        var d = normalizeString(row.domain != null ? row.domain : row.Domain);
        var suf = normalizeDomainSuffix(d);
        if (suf) list.push(suf);
      }
    }
    if (senderDomainSuffix) list.push(senderDomainSuffix);
    return uniq(list).map(function (d) {
      return lower(d);
    });
  }

  function shouldIgnoreAttachment(attachment, isNotTreatedAsAttachmentsAtHtmlEmbeddedFiles) {
    if (!attachment) return true;

    var name = normalizeString(attachment.name != null ? attachment.name : attachment.FileName);
    if (!name) return true;

    var fileType = attachmentFileType(name);
    if (fileType === ".p7s" || fileType === "p7s") return true;

    if (!!isNotTreatedAsAttachmentsAtHtmlEmbeddedFiles) {
      try {
        if (attachment.isInline === true) return true;
      } catch (_e) {}
    }

    return false;
  }

  function computeAttachments(checkList, snapshot, settings, locale) {
    var attachmentsSetting = (settings && settings.attachmentsSetting) || {};
    var general = (settings && settings.general) || {};
    var isIgnoreInline = !!general.isNotTreatedAsAttachmentsAtHtmlEmbeddedFiles;
    var runtime = (settings && settings.runtime) || {};
    var largeBytes = typeof runtime.largeAttachmentBytes === "number" ? runtime.largeAttachmentBytes : 10485760;

    var raw = snapshot && Array.isArray(snapshot.attachments) ? snapshot.attachments : [];
    for (var i = 0; i < raw.length; i++) {
      var a = raw[i];
      if (shouldIgnoreAttachment(a, isIgnoreInline)) continue;

      var fileName = normalizeString(a.name != null ? a.name : a.fileName);
      var bytes = typeof a.size === "number" ? a.size : typeof a.fileSizeBytes === "number" ? a.fileSizeBytes : NaN;
      var fileType = attachmentFileType(fileName);

      var isTooBig = typeof bytes === "number" && isFinite(bytes) && bytes >= largeBytes;
      if (isTooBig) {
        pushAlert(checkList, t(locale, "largeAttachment") + " [" + fileName + "]", true, false, false);
      }

      var isDangerous = fileType === ".exe";
      if (isDangerous) {
        pushAlert(checkList, t(locale, "dangerousExe") + " [" + fileName + "]", true, false, false);
      }

      var isEncrypted = false;
      if (
        (!!attachmentsSetting.isWarningWhenEncryptedZipIsAttached ||
          !!attachmentsSetting.isProhibitedWhenEncryptedZipIsAttached) &&
        fileName
      ) {
        // Office.js compose events don't reliably allow reading attachment bytes.
        // For now we treat ".zip" as "possibly encrypted zip" (best-effort).
        if (fileType === ".zip" || fileType === "zip") {
          isEncrypted = true;
          pushAlert(checkList, t(locale, "encryptedZip") + " [" + fileName + "]", true, false, false);

          if (!!attachmentsSetting.isProhibitedWhenEncryptedZipIsAttached) {
            checkList.isCanNotSendMail = true;
            checkList.canNotSendMailMessage = t(locale, "encryptedZip") + " [" + fileName + "]";
          }
        }
      }

      var isChecked = false;
      if (!attachmentsSetting.isMustOpenBeforeCheckTheAttachedFiles) {
        isChecked = !!general.isAutoCheckAttachments;
      }

      checkList.attachments.push({
        fileName: fileName,
        fileType: fileType || "",
        fileSize: formatBytes(bytes),
        fileSizeBytes: bytes,
        isTooBig: isTooBig,
        isDangerous: isDangerous,
        isEncrypted: isEncrypted,
        isChecked: !!isChecked,
      });
    }

    return checkList;
  }

  function checkForgotAttach(checkList, settings, locale) {
    var g = (settings && settings.general) || {};
    if (checkList.attachments.length >= 1) return checkList;
    if (!g.enableForgottenToAttachAlert) return checkList;

    var body = lower(checkList.mailBody);
    if (!body) return checkList;

    // OutlookOkan uses a single localized keyword; we support common variants.
    var keywords = ["添付", "attached file", "attach", "attachment", "attached"];
    for (var i = 0; i < keywords.length; i++) {
      if (body.indexOf(lower(keywords[i])) >= 0) {
        pushAlert(checkList, t(locale, "forgotAttach"), true, false, false);
        break;
      }
    }

    return checkList;
  }

  function checkAlertKeywords(checkList, list, targetText) {
    if (!Array.isArray(list) || list.length === 0) return checkList;
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!row) continue;
      var keyword = normalizeString(row.alertKeyword != null ? row.alertKeyword : row.AlertKeyword);
      if (!keyword) continue;

      if (keyword !== "*" && String(targetText || "").indexOf(keyword) < 0) continue;

      var message = normalizeString(row.message != null ? row.message : row.Message);
      var isCanNotSend = !!(row.isCanNotSend != null ? row.isCanNotSend : row.IsCanNotSend);
      var alertMessage = message ? message : "Alert keyword [" + keyword + "]";

      pushAlert(checkList, alertMessage, true, false, false);

      if (isCanNotSend) {
        checkList.isCanNotSendMail = true;
        checkList.canNotSendMailMessage = alertMessage;
      }
    }
    return checkList;
  }

  function applyAutoDeleteRecipients(recipients, autoDeleteRecipients, checkList, locale) {
    if (!Array.isArray(autoDeleteRecipients) || autoDeleteRecipients.length === 0) return recipients;

    var patterns = [];
    for (var i = 0; i < autoDeleteRecipients.length; i++) {
      var row = autoDeleteRecipients[i];
      if (!row) continue;
      var p = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!p) continue;
      patterns.push(lower(p));
    }
    if (patterns.length === 0) return recipients;

    var removedCount = 0;

    function filter(list) {
      var out = [];
      for (var j = 0; j < list.length; j++) {
        var r = list[j];
        if (!r || !r.key) continue;
        var address = r.key;
        var keep = true;

        for (var k = 0; k < patterns.length; k++) {
          var ptn = patterns[k];
          if (!ptn) continue;

          if (startsWith(ptn, "@") && endsWith(address, ptn)) {
            keep = false;
            break;
          }
          if (address === ptn) {
            keep = false;
            break;
          }
        }

        if (keep) out.push(r);
        else removedCount++;
      }
      return out;
    }

    var next = {
      to: filter(recipients.to),
      cc: filter(recipients.cc),
      bcc: filter(recipients.bcc),
    };

    if (removedCount > 0) {
      pushAlert(checkList, t(locale, "removedRecipients"), true, true, true);
    }

    if (next.to.length + next.cc.length + next.bcc.length === 0) {
      checkList.isCanNotSendMail = true;
      checkList.canNotSendMailMessage = t(locale, "allRecipientsRemoved");
    }

    return next;
  }

  function applyAutoCcBccRules(recipients, settings, checkList, locale, externalDomainCountAll, senderEmail, matchExtraKeys) {
    var g = (settings && settings.general) || {};

    var allowKeywordRules = !(
      externalDomainCountAll === 0 && !!g.isDoNotUseAutoCcBccKeywordIfAllRecipientsAreInternalDomain
    );
    var allowAttachedFileRules = !(
      externalDomainCountAll === 0 && !!g.isDoNotUseAutoCcBccAttachedFileIfAllRecipientsAreInternalDomain
    );

    var to = recipients.to.slice();
    var cc = recipients.cc.slice();
    var bcc = recipients.bcc.slice();

    var whitelistExtra = [];

    function hasRecipientSubstring(target) {
      var t2 = lower(normalizeString(target));
      if (!t2) return false;
      var all = to.concat(cc).concat(bcc);
      for (var i = 0; i < all.length; i++) {
        if (all[i].key && all[i].key.indexOf(t2) >= 0) return true;
      }
      if (Array.isArray(matchExtraKeys)) {
        for (var j = 0; j < matchExtraKeys.length; j++) {
          var k = matchExtraKeys[j];
          if (k && String(k).indexOf(t2) >= 0) return true;
        }
      }
      return false;
    }

    function addRecipient(field, email, reason) {
      var e = normalizeString(email);
      if (!e || e.indexOf("@") < 0) return;
      var key = lower(e);

      var fieldList = field === "Cc" ? cc : bcc;
      for (var i = 0; i < fieldList.length; i++) {
        if (fieldList[i].key === key) return;
      }

      var r = { emailAddress: e, displayName: "", key: key, formatted: e };
      fieldList.push(r);

      pushAlert(
        checkList,
        t(locale, "autoAddedRecipient") + " [" + field + "] [" + e + "] (" + reason + ")",
        false,
        true,
        true
      );

      whitelistExtra.push({ whiteName: e, isSkipConfirmation: false });
    }

    if (allowKeywordRules && Array.isArray(settings.autoCcBccKeyword) && settings.autoCcBccKeyword.length > 0) {
      for (var i = 0; i < settings.autoCcBccKeyword.length; i++) {
        var row = settings.autoCcBccKeyword[i];
        if (!row) continue;
        var keyword = normalizeString(row.keyword != null ? row.keyword : row.Keyword);
        var target = normalizeString(row.autoAddAddress != null ? row.autoAddAddress : row.AutoAddAddress);
        var ccOrBcc = normalizeString(row.ccOrBcc != null ? row.ccOrBcc : row.CcOrBcc);
        if (!keyword || !target) continue;
        if (String(checkList.mailBody || "").indexOf(keyword) < 0) continue;
        addRecipient(ccOrBcc === "Cc" ? "Cc" : "Bcc", target, "keyword: " + keyword);
      }
    }

    if (
      allowAttachedFileRules &&
      checkList.attachments.length > 0 &&
      Array.isArray(settings.autoCcBccAttachedFile) &&
      settings.autoCcBccAttachedFile.length > 0
    ) {
      for (var j = 0; j < settings.autoCcBccAttachedFile.length; j++) {
        var arow = settings.autoCcBccAttachedFile[j];
        if (!arow) continue;
        var add = normalizeString(arow.autoAddAddress != null ? arow.autoAddAddress : arow.AutoAddAddress);
        var ab = normalizeString(arow.ccOrBcc != null ? arow.ccOrBcc : arow.CcOrBcc);
        if (!add) continue;
        addRecipient(ab === "Cc" ? "Cc" : "Bcc", add, "attachment");
      }
    }

    if (Array.isArray(settings.autoCcBccRecipient) && settings.autoCcBccRecipient.length > 0) {
      for (var k = 0; k < settings.autoCcBccRecipient.length; k++) {
        var rrow = settings.autoCcBccRecipient[k];
        if (!rrow) continue;
        var targetRecipient = normalizeString(
          rrow.targetRecipient != null ? rrow.targetRecipient : rrow.TargetRecipient
        );
        var addAddr = normalizeString(rrow.autoAddAddress != null ? rrow.autoAddAddress : rrow.AutoAddAddress);
        var rb = normalizeString(rrow.ccOrBcc != null ? rrow.ccOrBcc : rrow.CcOrBcc);
        if (!targetRecipient || !addAddr) continue;
        if (!hasRecipientSubstring(targetRecipient)) continue;
        addRecipient(rb === "Cc" ? "Cc" : "Bcc", addAddr, "recipient: " + targetRecipient);
      }
    }

    if (senderEmail && senderEmail.indexOf("@") >= 0) {
      if (!!g.isAutoAddSenderToCc) addRecipient("Cc", senderEmail, "sender");
      if (!!g.isAutoAddSenderToBcc) addRecipient("Bcc", senderEmail, "sender");
    }

    return {
      recipients: dedupeRecipients(to, cc, bcc),
      whitelistExtra: whitelistExtra,
    };
  }

  function externalDomainsChangeToBccIfNeeded(recipients, settings, checkList, locale, internalDomains, senderEmail, senderDomainSuffix) {
    var ex = (settings && settings.externalDomains) || {};
    var force = (settings && settings.forceAutoChangeRecipientsToBcc) || {};

    var threshold = typeof ex.targetToAndCcExternalDomainsNum === "number" ? ex.targetToAndCcExternalDomainsNum : 10;
    var externalDomainNumToAndCc = countRecipientExternalDomains(recipients, senderDomainSuffix, internalDomains, true);

    var shouldForce = !!force.isForceAutoChangeRecipientsToBcc;
    var shouldAuto =
      !!ex.isAutoChangeToBccWhenLargeNumberOfExternalDomains &&
      !ex.isProhibitedWhenLargeNumberOfExternalDomains &&
      threshold <= externalDomainNumToAndCc;

    if (!shouldForce && !shouldAuto) return recipients;

    var internalForConvert = internalDomains.slice();
    if (shouldForce && !!force.isIncludeInternalDomain) {
      internalForConvert = []; // include internal domain in conversion
    }

    var to = [];
    var cc = [];
    var bcc = recipients.bcc.slice();

    function move(list, outList) {
      for (var i = 0; i < list.length; i++) {
        var r = list[i];
        if (!r) continue;
        var isInternal = internalForConvert.length > 0 && isInternalAddress(r.emailAddress, internalForConvert);
        if (isInternal) outList.push(r);
        else bcc.push(r);
      }
    }

    move(recipients.to, to);
    move(recipients.cc, cc);

    if (shouldForce) {
      pushAlert(checkList, t(locale, "forceToBccChanged") + " [" + threshold + "]", false, false, true);
    } else {
      pushAlert(checkList, t(locale, "externalToBccChanged") + " [" + threshold + "]", true, false, false);
    }

    var toRecipient = normalizeString(force.toRecipient);
    var addTo = toRecipient || senderEmail;
    if (to.length === 0 && addTo) {
      to.push({ emailAddress: addTo, displayName: "", key: lower(addTo), formatted: addTo });
      pushAlert(checkList, t(locale, "autoAddSenderToTo"), true, false, false);
    }

    return dedupeRecipients(to, cc, bcc);
  }

  function applyRecipientChecks(checkList, recipients, settings, locale, internalDomains, effectiveWhitelist, expandedByField) {
    var alerts = Array.isArray(settings.alertAddresses) ? settings.alertAddresses : [];

    function addAddress(outList, recipient, seen) {
      var email = recipient.emailAddress;
      var key = lower(email);
      if (key && seen[key]) return;
      if (key) seen[key] = true;
      var formatted = recipient.formatted || email;

      var external = !isInternalAddress(email, internalDomains);
      var white = isWhitelisted(email, effectiveWhitelist);
      var skip = white ? isSkipConfirmation(email, effectiveWhitelist) : false;
      var expandedFrom = normalizeString(recipient.expandedFrom);

      outList.push({
        mailAddress: formatted,
        emailAddress: email,
        isExternal: external,
        isWhite: white,
        isSkip: skip,
        isChecked: white,
        isExpanded: !!expandedFrom,
        expandedFrom: expandedFrom,
      });

      for (var i = 0; i < alerts.length; i++) {
        var row = alerts[i];
        if (!row) continue;
        var target = normalizeString(row.targetAddress != null ? row.targetAddress : row.TargetAddress);
        if (!target) continue;
        if (!addressMatchesTarget(email, target)) continue;

        var isCanNotSend = !!(row.isCanNotSend != null ? row.isCanNotSend : row.IsCanNotSend);
        var message = normalizeString(row.message != null ? row.message : row.Message);

        if (isCanNotSend) {
          checkList.isCanNotSendMail = true;
          checkList.canNotSendMailMessage = t(locale, "forbid") + ": " + formatted;
          continue;
        }

        pushAlert(checkList, (message ? message : "Alert address") + " [" + formatted + "]", true, false, false);
      }
    }

    var seenTo = {};
    var seenCc = {};
    var seenBcc = {};

    for (var i = 0; i < recipients.to.length; i++) addAddress(checkList.toAddresses, recipients.to[i], seenTo);
    for (var j = 0; j < recipients.cc.length; j++) addAddress(checkList.ccAddresses, recipients.cc[j], seenCc);
    for (var k = 0; k < recipients.bcc.length; k++) addAddress(checkList.bccAddresses, recipients.bcc[k], seenBcc);

    var ex = expandedByField || {};
    var exTo = Array.isArray(ex.to) ? ex.to : [];
    var exCc = Array.isArray(ex.cc) ? ex.cc : [];
    var exBcc = Array.isArray(ex.bcc) ? ex.bcc : [];

    for (var e1 = 0; e1 < exTo.length; e1++) addAddress(checkList.toAddresses, exTo[e1], seenTo);
    for (var e2 = 0; e2 < exCc.length; e2++) addAddress(checkList.ccAddresses, exCc[e2], seenCc);
    for (var e3 = 0; e3 < exBcc.length; e3++) addAddress(checkList.bccAddresses, exBcc[e3], seenBcc);

    return checkList;
  }

  function applyContactsChecks(checkList, settings, locale, contactsInfo) {
    var g = (settings && settings.general) || {};

    var autoCheck = !!g.isAutoCheckRegisteredInContacts;
    var warn = !!g.isWarningIfRecipientsIsNotRegistered;
    var prohibit = !!g.isProhibitsSendingMailIfRecipientsIsNotRegistered;

    if (!autoCheck && !warn && !prohibit) return checkList;

    var info = contactsInfo && contactsInfo.resolved && isObject(contactsInfo.resolved) ? contactsInfo.resolved : {};
    var map = info && isObject(info.contacts) ? info.contacts : null;
    var lookupFailed = !!(info && info.contactsLookupFailed);

    if (!map) {
      if (warn || prohibit) {
        pushAlert(checkList, t(locale, "contactsLookupUnavailable"), true, false, false);
      }
      return checkList;
    }

    var unknown = [];

    function handle(list) {
      for (var i = 0; i < list.length; i++) {
        var addr = list[i];
        if (!addr || !addr.emailAddress) continue;
        if (!addr.isExternal) continue; // internal domain is excluded
        var k = lower(addr.emailAddress);
        var v = map[k];

        if (v === true) {
          addr.isRegisteredInContacts = true;
          if (autoCheck) addr.isChecked = true;
          continue;
        }

        if (v === false) {
          addr.isRegisteredInContacts = false;

          if (prohibit) {
            checkList.isCanNotSendMail = true;
            checkList.canNotSendMailMessage = t(locale, "contactsNotRegisteredProhibit") + " [" + addr.mailAddress + "]";
            return false;
          }

          if (warn) {
            pushAlert(
              checkList,
              t(locale, "contactsNotRegisteredWarning") + " [" + addr.mailAddress + "]",
              true,
              false,
              false
            );
          }
          continue;
        }

        addr.isRegisteredInContacts = null;
        unknown.push(addr.mailAddress);
      }
      return true;
    }

    if (!handle(checkList.toAddresses)) return checkList;
    if (!handle(checkList.ccAddresses)) return checkList;
    if (!handle(checkList.bccAddresses)) return checkList;

    if (unknown.length > 0) {
      pushAlert(
        checkList,
        t(locale, "contactsLookupIncomplete") +
          " (" +
          String(unknown.length) +
          "): " +
          unknown.slice(0, 3).join(", ") +
          (unknown.length > 3 ? "..." : ""),
        true,
        false,
        false
      );
    }

    if (lookupFailed) {
      pushAlert(checkList, t(locale, "contactsLookupUnavailable"), true, false, false);
    }

    return checkList;
  }

  function checkRecipientsAndAttachments(checkList, settings, locale) {
    var attachmentsSetting = (settings && settings.attachmentsSetting) || {};

    if (checkList.attachments.length <= 0) return checkList;

    if (!!attachmentsSetting.isAttachmentsProhibited) {
      checkList.isCanNotSendMail = true;
      checkList.canNotSendMailMessage = t(locale, "attachmentsProhibited");
      return checkList;
    }

    var prohibitedList = Array.isArray(settings.attachmentProhibitedRecipients) ? settings.attachmentProhibitedRecipients : [];
    if (prohibitedList.length > 0) {
      var prohibitedRecipients = [];
      var isProhibited = false;

      function scan(list, recipientPattern) {
        var pat = lower(recipientPattern);
        for (var i = 0; i < list.length; i++) {
          var addr = list[i];
          if (!addr || !addr.emailAddress) continue;
          if (lower(addr.emailAddress).indexOf(pat) >= 0) {
            prohibitedRecipients.push(addr.mailAddress);
            isProhibited = true;
          }
        }
      }

      for (var p = 0; p < prohibitedList.length; p++) {
        var pr = prohibitedList[p];
        if (!pr) continue;
        var pat2 = normalizeString(pr.recipient != null ? pr.recipient : pr.Recipient);
        if (!pat2) continue;
        scan(checkList.toAddresses, pat2);
        scan(checkList.ccAddresses, pat2);
        scan(checkList.bccAddresses, pat2);
      }

      if (isProhibited) {
        checkList.isCanNotSendMail = true;
        checkList.canNotSendMailMessage =
          t(locale, "attachmentProhibitedRecipients") + ": " + uniq(prohibitedRecipients).join(" ");
        return checkList;
      }
    }

    var alertRecipients = Array.isArray(settings.attachmentAlertRecipients) ? settings.attachmentAlertRecipients : [];
    if (alertRecipients.length > 0) {
      for (var a = 0; a < alertRecipients.length; a++) {
        var ar = alertRecipients[a];
        if (!ar) continue;
        var target = normalizeString(ar.recipient != null ? ar.recipient : ar.Recipient);
        if (!target) continue;
        var msg = normalizeString(ar.message != null ? ar.message : ar.Message);
        var text = msg ? msg : t(locale, "attachmentAlertRecipients");
        var tLower = lower(target);

        function warn(list) {
          for (var i = 0; i < list.length; i++) {
            if (lower(list[i].emailAddress).indexOf(tLower) >= 0) {
              pushAlert(checkList, text + " [" + list[i].mailAddress + "]", true, false, false);
            }
          }
        }

        warn(checkList.toAddresses);
        warn(checkList.ccAddresses);
        warn(checkList.bccAddresses);
      }
    }

    var mapList = Array.isArray(settings.recipientsAndAttachmentsName) ? settings.recipientsAndAttachmentsName : [];
    if (mapList.length > 0) {
      for (var m = 0; m < mapList.length; m++) {
        var map = mapList[m];
        if (!map) continue;
        var attachmentsName = normalizeString(map.attachmentsName != null ? map.attachmentsName : map.AttachmentsName);
        var recipient = normalizeString(map.recipient != null ? map.recipient : map.Recipient);
        if (!attachmentsName || !recipient) continue;
        var recipientLower = lower(recipient);

        for (var iAtt = 0; iAtt < checkList.attachments.length; iAtt++) {
          var att = checkList.attachments[iAtt];
          if (!att || !att.fileName) continue;
          if (att.fileName.indexOf(attachmentsName) < 0) continue;

          function check(list) {
            for (var i = 0; i < list.length; i++) {
              var addr = list[i];
              if (!addr || !addr.isExternal) continue;
              if (lower(addr.emailAddress).indexOf(recipientLower) >= 0) continue;
              pushAlert(
                checkList,
                t(locale, "recipientsAndAttachmentsName") + ": " + addr.mailAddress + " / " + att.fileName,
                true,
                true,
                false
              );
            }
          }

          check(checkList.toAddresses);
          check(checkList.ccAddresses);
          check(checkList.bccAddresses);
        }
      }
    }

    if (!!attachmentsSetting.isWarningWhenAttachedRealFile) {
      pushAlert(checkList, t(locale, "recommendLink"), false, true, false);
    }

    return checkList;
  }

  function checkNameAndDomains(checkList, recipientsAll, settings, locale) {
    var g = (settings && settings.general) || {};
    var list = Array.isArray(settings.nameAndDomains) ? settings.nameAndDomains : [];
    if (list.length === 0) return checkList;

    var cleaned = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!row) continue;
      var name = normalizeString(row.name != null ? row.name : row.Name);
      var domain = normalizeString(row.domain != null ? row.domain : row.Domain);
      if (!name || !domain) continue;
      cleaned.push({ name: name, domain: domain });
    }
    if (cleaned.length === 0) return checkList;

    var includeSubject = !!g.isCheckNameAndDomainsIncludeSubject;

    // 1) If requested, warn when linked name is not found for recipients in that domain.
    if (!!g.isCheckNameAndDomainsFromRecipients || (includeSubject && !!g.isCheckNameAndDomainsFromSubject)) {
      var candidates = [];
      for (var c = 0; c < cleaned.length; c++) {
        for (var r = 0; r < recipientsAll.length; r++) {
          var addr = recipientsAll[r];
          if (!addr || !addr.emailAddress) continue;
          if (addressMatchesTarget(addr.emailAddress, cleaned[c].domain)) {
            candidates.push([addr.formatted, cleaned[c].name]);
          }
        }
      }

      if (candidates.length > 0 && !!g.isCheckNameAndDomainsFromRecipients) {
        var missCount = 0;
        for (var i2 = 0; i2 < candidates.length; i2++) {
          var pair = candidates[i2];
          if (String(checkList.mailBody || "").indexOf(pair[1]) < 0 && pair[0].indexOf(checkList.senderDomain) < 0) {
            missCount++;
          }
        }
        if (missCount >= candidates.length) {
          for (var i3 = 0; i3 < candidates.length; i3++) {
            var pair2 = candidates[i3];
            if (String(checkList.mailBody || "").indexOf(pair2[1]) < 0 && pair2[0].indexOf(checkList.senderDomain) < 0) {
              pushAlert(
                checkList,
                pair2[0] + " : " + t(locale, "nameDomainMissingInBody") + " (" + pair2[1] + ")",
                true,
                false,
                false
              );
            }
          }
        }
      }

      if (candidates.length > 0 && includeSubject && !!g.isCheckNameAndDomainsFromSubject) {
        var missSub = 0;
        for (var i4 = 0; i4 < candidates.length; i4++) {
          var pair3 = candidates[i4];
          if (String(checkList.subject || "").indexOf(pair3[1]) < 0 && pair3[0].indexOf(checkList.senderDomain) < 0) {
            missSub++;
          }
        }
        if (missSub >= candidates.length) {
          for (var i5 = 0; i5 < candidates.length; i5++) {
            var pair4 = candidates[i5];
            if (String(checkList.subject || "").indexOf(pair4[1]) < 0 && pair4[0].indexOf(checkList.senderDomain) < 0) {
              pushAlert(
                checkList,
                pair4[0] + " : " + t(locale, "nameDomainMissingInSubject") + " (" + pair4[1] + ")",
                true,
                false,
                false
              );
            }
          }
        }
      }
    }

    // 2) If any names are found in text, warn for recipients outside candidate domains.
    var targetText = String(checkList.mailBody || "");
    if (includeSubject) targetText += String(checkList.subject || "");

    var candidateDomains = [];
    for (var j = 0; j < cleaned.length; j++) {
      if (targetText.indexOf(cleaned[j].name) >= 0) candidateDomains.push(cleaned[j].domain);
    }
    if (candidateDomains.length === 0) return checkList;

    for (var r2 = 0; r2 < recipientsAll.length; r2++) {
      var rec = recipientsAll[r2];
      if (!rec || !rec.emailAddress) continue;
      var ok = false;
      for (var d = 0; d < candidateDomains.length; d++) {
        if (addressMatchesTarget(rec.emailAddress, candidateDomains[d])) {
          ok = true;
          break;
        }
      }
      if (ok) continue;
      if (rec.key.indexOf(checkList.senderDomain) >= 0) continue;

      pushAlert(checkList, rec.formatted + " : " + t(locale, "maybeIrrelevantRecipient"), true, false, false);
    }

    return checkList;
  }

  function checkKeywordAndRecipients(checkList, recipientsAll, settings, locale) {
    var g = (settings && settings.general) || {};
    var list = Array.isArray(settings.keywordAndRecipients) ? settings.keywordAndRecipients : [];
    if (list.length === 0) return checkList;

    var cleaned = [];
    for (var i = 0; i < list.length; i++) {
      var row = list[i];
      if (!row) continue;
      var keyword = normalizeString(row.keyword != null ? row.keyword : row.Keyword);
      var recipient = normalizeString(row.recipient != null ? row.recipient : row.Recipient);
      if (!keyword || !recipient) continue;
      cleaned.push({ keyword: keyword, recipient: recipient });
    }
    if (cleaned.length === 0) return checkList;

    var targetText = String(checkList.mailBody || "");
    if (!!g.isCheckKeywordAndRecipientsIncludeSubject) targetText += String(checkList.subject || "");

    for (var j = 0; j < cleaned.length; j++) {
      var rule = cleaned[j];
      if (targetText.indexOf(rule.keyword) < 0) continue;

      var has = false;
      for (var r = 0; r < recipientsAll.length; r++) {
        if (addressMatchesTarget(recipientsAll[r].emailAddress, rule.recipient)) {
          has = true;
          break;
        }
      }
      if (!has) {
        pushAlert(
          checkList,
          t(locale, "keywordAndRecipients") + ": " + rule.keyword + " -> " + rule.recipient,
          true,
          false,
          false
        );
      }
    }

    return checkList;
  }

  function externalDomainsWarningIfNeeded(checkList, settings, locale, externalDomainNumToAndCc) {
    var ex = (settings && settings.externalDomains) || {};
    var force = (settings && settings.forceAutoChangeRecipientsToBcc) || {};
    if (!!force.isForceAutoChangeRecipientsToBcc) return checkList;

    var threshold = typeof ex.targetToAndCcExternalDomainsNum === "number" ? ex.targetToAndCcExternalDomainsNum : 10;
    if (threshold > externalDomainNumToAndCc) return checkList;

    if (!!ex.isProhibitedWhenLargeNumberOfExternalDomains) {
      checkList.isCanNotSendMail = true;
      checkList.canNotSendMailMessage = t(locale, "externalDomainProhibited") + " [" + threshold + "]";
      return checkList;
    }

    if (!!ex.isWarningWhenLargeNumberOfExternalDomains && !ex.isAutoChangeToBccWhenLargeNumberOfExternalDomains) {
      pushAlert(checkList, t(locale, "externalDomainWarning") + " [" + threshold + "]", true, false, false);
    }

    return checkList;
  }

  function applyAutoAddMessagePreview(checkList, settings, locale) {
    var autoAdd = (settings && settings.autoAddMessage) || {};
    if (!autoAdd || (!autoAdd.isAddToStart && !autoAdd.isAddToEnd)) return checkList;
    if (checkList.mailBody == null) return checkList;

    if (!!autoAdd.isAddToStart && normalizeString(autoAdd.messageOfAddToStart)) {
      pushAlert(checkList, t(locale, "addedTextStart"), false, false, true);
    }
    if (!!autoAdd.isAddToEnd && normalizeString(autoAdd.messageOfAddToEnd)) {
      pushAlert(checkList, t(locale, "addedTextEnd"), false, false, true);
    }
    return checkList;
  }

  function defaultLocale(settings, snapshot) {
    var general = (settings && settings.general) || {};
    var lang = normalizeString(general.languageCode);
    if (lang) return lang;
    var dl = normalizeString(snapshot && snapshot.displayLanguage);
    if (dl) return dl;
    return "en-US";
  }

  function evaluate(snapshot, settings) {
    if (!isObject(snapshot)) snapshot = {};
    if (!isObject(settings)) settings = {};

    var locale = lower(defaultLocale(settings, snapshot));

    var senderEmail = normalizeString(
      snapshot.senderEmailAddress ||
        (snapshot.sender && snapshot.sender.emailAddress) ||
        (snapshot.sender && snapshot.sender.address) ||
        ""
    );
    var senderDomainSuffix = domainSuffixFromAddress(senderEmail);

    var internalDomains = buildInternalDomains(settings, senderDomainSuffix);

    var to = normalizeRecipients(snapshot.to || (snapshot.recipients && snapshot.recipients.to) || []);
    var cc = normalizeRecipients(snapshot.cc || (snapshot.recipients && snapshot.recipients.cc) || []);
    var bcc = normalizeRecipients(snapshot.bcc || (snapshot.recipients && snapshot.recipients.bcc) || []);
    var recipients = dedupeRecipients(to, cc, bcc);

    var checkList = {
      alerts: [],
      toAddresses: [],
      ccAddresses: [],
      bccAddresses: [],
      attachments: [],
      sender: senderEmail,
      senderDomain: senderDomainSuffix || "",
      recipientExternalDomainNumAll: 0,
      subject: normalizeString(snapshot.subject),
      mailType: normalizeString(snapshot.itemType) || "Message",
      mailBody: normalizeString(snapshot.bodyText),
      isCanNotSendMail: false,
      canNotSendMailMessage: "",
    };

    var g = (settings && settings.general) || {};
    var itemType = lower(checkList.mailType);
    if (itemType === "appointment" && !g.isShowConfirmationAtSendMeetingRequest) {
      return {
        checkList: checkList,
        mutations: { to: toEmailList(recipients.to), cc: toEmailList(recipients.cc), bcc: toEmailList(recipients.bcc) },
        showConfirmation: false,
        locale: locale,
      };
    }

    recipients = applyAutoDeleteRecipients(recipients, settings.autoDeleteRecipients, checkList, locale);
    if (checkList.isCanNotSendMail) {
      return {
        checkList: checkList,
        mutations: { to: toEmailList(recipients.to), cc: toEmailList(recipients.cc), bcc: toEmailList(recipients.bcc) },
        showConfirmation: true,
        locale: locale,
      };
    }

    var expanded = normalizeExpandedGroups(snapshot, recipients);

    computeAttachments(checkList, snapshot, settings, locale);
    checkForgotAttach(checkList, settings, locale);
    checkAlertKeywords(checkList, settings.alertKeywordsBody, checkList.mailBody);
    checkAlertKeywords(checkList, settings.alertKeywordsSubject, checkList.subject);

    applyAutoAddMessagePreview(checkList, settings, locale);

    var recipientsForCounts = {
      to: recipients.to.concat(expanded.to),
      cc: recipients.cc.concat(expanded.cc),
      bcc: recipients.bcc.concat(expanded.bcc),
    };

    var externalDomainCountAll = countRecipientExternalDomains(
      recipientsForCounts,
      senderDomainSuffix,
      internalDomains,
      false
    );

    var expandedKeys = [];
    for (var ek = 0; ek < expanded.all.length; ek++) {
      if (expanded.all[ek] && expanded.all[ek].key) expandedKeys.push(expanded.all[ek].key);
    }

    var autoAdd = applyAutoCcBccRules(
      recipients,
      settings,
      checkList,
      locale,
      externalDomainCountAll,
      senderEmail,
      expandedKeys
    );
    recipients = autoAdd.recipients;

    recipients = externalDomainsChangeToBccIfNeeded(
      recipients,
      settings,
      checkList,
      locale,
      internalDomains,
      senderEmail,
      senderDomainSuffix
    );

    var effectiveWhitelist = []
      .concat(Array.isArray(settings.whitelist) ? settings.whitelist : [])
      .concat(Array.isArray(autoAdd.whitelistExtra) ? autoAdd.whitelistExtra : []);

    if (!!g.contactGroupMembersAreWhite || !!g.exchangeDistributionListMembersAreWhite) {
      for (var wl = 0; wl < expanded.all.length; wl++) {
        if (!expanded.all[wl] || !expanded.all[wl].emailAddress) continue;
        effectiveWhitelist.push({ whiteName: expanded.all[wl].emailAddress, isSkipConfirmation: false });
      }
    }

    applyRecipientChecks(checkList, recipients, settings, locale, internalDomains, effectiveWhitelist, expanded);

    if (!!g.isAutoCheckIfAllRecipientsAreSameDomain) {
      var i;
      for (i = 0; i < checkList.toAddresses.length; i++) if (!checkList.toAddresses[i].isExternal) checkList.toAddresses[i].isChecked = true;
      for (i = 0; i < checkList.ccAddresses.length; i++) if (!checkList.ccAddresses[i].isExternal) checkList.ccAddresses[i].isChecked = true;
      for (i = 0; i < checkList.bccAddresses.length; i++) if (!checkList.bccAddresses[i].isExternal) checkList.bccAddresses[i].isChecked = true;
    }

    applyContactsChecks(checkList, settings, locale, snapshot);
    if (checkList.isCanNotSendMail) {
      return {
        checkList: checkList,
        mutations: { to: toEmailList(recipients.to), cc: toEmailList(recipients.cc), bcc: toEmailList(recipients.bcc) },
        showConfirmation: true,
        locale: locale,
      };
    }

    checkRecipientsAndAttachments(checkList, settings, locale);

    var allRecipients = dedupeRecipientList(recipients.to.concat(recipients.cc).concat(recipients.bcc).concat(expanded.all));
    checkNameAndDomains(checkList, allRecipients, settings, locale);
    checkKeywordAndRecipients(checkList, allRecipients, settings, locale);

    var recipientsForCounts2 = {
      to: recipients.to.concat(expanded.to),
      cc: recipients.cc.concat(expanded.cc),
      bcc: recipients.bcc.concat(expanded.bcc),
    };

    var externalDomainNumToAndCc = countRecipientExternalDomains(recipientsForCounts2, senderDomainSuffix, internalDomains, true);
    checkList.recipientExternalDomainNumAll = countRecipientExternalDomains(
      recipientsForCounts2,
      senderDomainSuffix,
      internalDomains,
      false
    );
    externalDomainsWarningIfNeeded(checkList, settings, locale, externalDomainNumToAndCc);

    var showConfirmation = computeShowConfirmation(checkList, g);

    if (!!g.isEnableRecipientsAreSortedByDomain) {
      function sortByDomain(a, b) {
        var da = domainSuffixFromAddress(a.emailAddress);
        var db = domainSuffixFromAddress(b.emailAddress);
        if (da < db) return -1;
        if (da > db) return 1;
        return a.emailAddress < b.emailAddress ? -1 : a.emailAddress > b.emailAddress ? 1 : 0;
      }
      checkList.toAddresses = checkList.toAddresses.slice().sort(sortByDomain);
      checkList.ccAddresses = checkList.ccAddresses.slice().sort(sortByDomain);
      checkList.bccAddresses = checkList.bccAddresses.slice().sort(sortByDomain);
    }

    return {
      checkList: checkList,
      mutations: { to: toEmailList(recipients.to), cc: toEmailList(recipients.cc), bcc: toEmailList(recipients.bcc) },
      showConfirmation: showConfirmation,
      locale: locale,
    };
  }

  ns.engine = {
    evaluate: evaluate,
    _domainSuffixFromAddress: domainSuffixFromAddress,
    _countRecipientExternalDomains: countRecipientExternalDomains,
  };
})();


"use strict";
(function () {
  var root =
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : undefined;
  if (!root) return;

  var ns = (root.MailChecker = root.MailChecker || {});

  function normalizeString(value) {
    return value == null ? "" : String(value).trim();
  }

  function lower(value) {
    return value == null ? "" : String(value).toLowerCase();
  }

  function startsWith(value, prefix) {
    return String(value || "").slice(0, String(prefix || "").length) === String(prefix || "");
  }

  function endsWith(value, suffix) {
    var s = String(value || "");
    var suf = String(suffix || "");
    if (!suf) return false;
    return s.slice(s.length - suf.length) === suf;
  }

  function domainSuffixFromAddress(address) {
    var a = normalizeString(address);
    if (!a) return "";
    var at = a.lastIndexOf("@");
    if (at < 0) return "";
    return lower(a.slice(at)); // includes "@"
  }

  function normalizeDomainSuffix(value) {
    var v = lower(normalizeString(value));
    if (!v) return "";
    if (v.indexOf("@") === 0) return v;
    if (v.indexOf("@") >= 0) return v.slice(v.lastIndexOf("@"));
    return "@" + v;
  }

  function buildInternalDomains(settings, senderDomainSuffix) {
    var list = [];
    try {
      if (settings && Array.isArray(settings.internalDomains)) {
        for (var i = 0; i < settings.internalDomains.length; i++) {
          var row = settings.internalDomains[i];
          if (!row) continue;
          var d = normalizeString(row.domain != null ? row.domain : row.Domain);
          var suf = normalizeDomainSuffix(d);
          if (suf) list.push(suf);
        }
      }
    } catch (_e) {}
    if (senderDomainSuffix) list.push(senderDomainSuffix);
    // uniq + lower
    var seen = {};
    var out = [];
    for (var j = 0; j < list.length; j++) {
      var k = lower(list[j]);
      if (!k || seen[k]) continue;
      seen[k] = true;
      out.push(k);
    }
    return out;
  }

  function isInternalAddress(address, internalDomains) {
    var a = lower(normalizeString(address));
    if (!a) return false;
    if (!Array.isArray(internalDomains) || internalDomains.length === 0) return false;
    for (var i = 0; i < internalDomains.length; i++) {
      var suf = internalDomains[i];
      if (!suf) continue;
      if (endsWith(a, suf)) return true;
    }
    return false;
  }

  function isDistributionListRecipient(recipient) {
    if (!recipient) return false;
    try {
      var rt = recipient.recipientType != null ? recipient.recipientType : recipient.RecipientType;
      if (rt == null) return false;
      var s = lower(rt);
      return s.indexOf("distribution") >= 0 || s.indexOf("group") >= 0;
    } catch (_e) {
      return false;
    }
  }

  async function enrichSnapshotWithEws(snapshot, settings, timeoutMs) {
    if (!snapshot || !settings) return snapshot;

    var g = (settings && settings.general) || {};
    var wantDl =
      !!g.enableGetContactGroupMembers ||
      !!g.enableGetExchangeDistributionListMembers;
    var wantContacts =
      !!g.isAutoCheckRegisteredInContacts ||
      !!g.isWarningIfRecipientsIsNotRegistered ||
      !!g.isProhibitsSendingMailIfRecipientsIsNotRegistered;

    if (!wantDl && !wantContacts) return snapshot;

    var ews = ns.ews;
    var canEws = !!(ews && typeof ews.canUseEws === "function" && ews.canUseEws());

    var resolved = { expandedGroups: [], contacts: null, contactsLookupFailed: false };

    if (!canEws) {
      if (wantContacts) resolved.contactsLookupFailed = true;
      snapshot.resolved = resolved;
      return snapshot;
    }

    var internalDomains = buildInternalDomains(settings, domainSuffixFromAddress(snapshot.senderEmailAddress));

    var deadline = 0;
    try {
      var maxBudget = Math.min(2200, Math.max(600, (timeoutMs || 0) - 1800));
      deadline = Date.now() + maxBudget;
    } catch (_e2) {
      deadline = 0;
    }

    function timeLeft() {
      try {
        return deadline ? deadline - Date.now() : 0;
      } catch (_e3) {
        return 0;
      }
    }

    function collectDlCandidates(list, field, outList, seen) {
      for (var i = 0; i < list.length; i++) {
        var r = list[i];
        if (!r) continue;
        var email = normalizeString(r.emailAddress);
        if (!email || email.indexOf("@") < 0) continue;
        var key = lower(email);
        if (seen[key]) continue;
        seen[key] = true;
        if (!isDistributionListRecipient(r)) continue;
        if (internalDomains.length > 0 && !isInternalAddress(email, internalDomains)) continue;
        outList.push({ emailAddress: email, displayName: normalizeString(r.displayName), field: field });
      }
    }

    if (wantDl && typeof ews.expandDlCached === "function") {
      try {
        var candidates = [];
        var seenDl = {};
        collectDlCandidates(snapshot.recipients && snapshot.recipients.to ? snapshot.recipients.to : [], "To", candidates, seenDl);
        collectDlCandidates(snapshot.recipients && snapshot.recipients.cc ? snapshot.recipients.cc : [], "Cc", candidates, seenDl);
        collectDlCandidates(snapshot.recipients && snapshot.recipients.bcc ? snapshot.recipients.bcc : [], "Bcc", candidates, seenDl);

        for (var c = 0; c < candidates.length && c < 3; c++) {
          if (timeLeft() < 300) break;
          var cand = candidates[c];
          var perTimeout = Math.max(300, Math.min(900, timeLeft()));
          var r1 = await ews.expandDlCached(cand.emailAddress, { timeoutMs: perTimeout });
          if (!r1 || !r1.ok || !Array.isArray(r1.members) || r1.members.length === 0) continue;

          var members = r1.members
            .map(function (m) {
              return {
                emailAddress: normalizeString(m && m.emailAddress),
                displayName: normalizeString(m && m.displayName),
              };
            })
            .filter(function (m) {
              return m.emailAddress && m.emailAddress.indexOf("@") >= 0;
            });

          if (members.length === 0) continue;

          resolved.expandedGroups.push({
            emailAddress: cand.emailAddress,
            displayName: cand.displayName,
            field: cand.field,
            members: members,
          });
        }
      } catch (_e4) {}
    }

    if (wantContacts && typeof ews.resolveInContactsCached === "function") {
      try {
        var emails = [];
        function addRecipients(list) {
          for (var i = 0; i < list.length; i++) {
            var r = list[i];
            if (!r) continue;
            var email = normalizeString(r.emailAddress);
            if (!email || email.indexOf("@") < 0) continue;
            if (internalDomains.length > 0 && isInternalAddress(email, internalDomains)) continue;
            emails.push(email);
          }
        }

        addRecipients((snapshot.recipients && snapshot.recipients.to) || []);
        addRecipients((snapshot.recipients && snapshot.recipients.cc) || []);
        addRecipients((snapshot.recipients && snapshot.recipients.bcc) || []);

        for (var g2 = 0; g2 < resolved.expandedGroups.length; g2++) {
          var grp = resolved.expandedGroups[g2];
          var members = (grp && grp.members) || [];
          for (var m2 = 0; m2 < members.length; m2++) {
            var em = normalizeString(members[m2] && members[m2].emailAddress);
            if (!em || em.indexOf("@") < 0) continue;
            if (internalDomains.length > 0 && isInternalAddress(em, internalDomains)) continue;
            emails.push(em);
          }
        }

        var seen = {};
        var uniq = [];
        for (var u = 0; u < emails.length; u++) {
          var k2 = lower(emails[u]);
          if (!k2 || seen[k2]) continue;
          seen[k2] = true;
          uniq.push(emails[u]);
        }

        var contacts = {};
        for (var q = 0; q < uniq.length; q++) {
          if (timeLeft() < 250) break;
          var email2 = uniq[q];
          var perTimeout2 = Math.max(250, Math.min(700, timeLeft()));
          var r2 = await ews.resolveInContactsCached(email2, { timeoutMs: perTimeout2 });
          if (r2 && r2.ok && typeof r2.value === "boolean") {
            contacts[lower(email2)] = r2.value;
          } else if (r2 && !r2.ok) {
            resolved.contactsLookupFailed = true;
          }
        }

        resolved.contacts = contacts;
      } catch (_e5) {
        resolved.contactsLookupFailed = true;
        resolved.contacts = null;
      }
    }

    snapshot.resolved = resolved;
    return snapshot;
  }

  function withTimeout(promise, ms, timeoutValue) {
    return new Promise(function (resolve) {
      var done = false;

      var id = null;
      try {
        if (typeof ms === "number" && isFinite(ms) && ms > 0) {
          id = setTimeout(function () {
            if (done) return;
            done = true;
            resolve(timeoutValue);
          }, ms);
        }
      } catch (_e) {}

      Promise.resolve(promise)
        .then(function (value) {
          if (done) return;
          done = true;
          try {
            if (id != null) clearTimeout(id);
          } catch (_e2) {}
          resolve(value);
        })
        .catch(function (_err) {
          if (done) return;
          done = true;
          try {
            if (id != null) clearTimeout(id);
          } catch (_e3) {}
          resolve(timeoutValue);
        });
    });
  }

  function pGetRecipients(recipientsObj) {
    return new Promise(function (resolve) {
      try {
        if (!recipientsObj || typeof recipientsObj.getAsync !== "function") return resolve([]);
        recipientsObj.getAsync(function (result) {
          try {
            if (!result || result.status !== Office.AsyncResultStatus.Succeeded) return resolve([]);
            resolve(Array.isArray(result.value) ? result.value : []);
          } catch (_e) {
            resolve([]);
          }
        });
      } catch (_e2) {
        resolve([]);
      }
    });
  }

  function pSetRecipients(recipientsObj, emails) {
    return new Promise(function (resolve) {
      try {
        if (!recipientsObj || typeof recipientsObj.setAsync !== "function") return resolve(false);
        var list = Array.isArray(emails)
          ? emails
              .map(function (e) {
                var v = normalizeString(e);
                return v ? { emailAddress: v } : null;
              })
              .filter(Boolean)
          : [];
        recipientsObj.setAsync(list, function (result) {
          try {
            resolve(!!result && result.status === Office.AsyncResultStatus.Succeeded);
          } catch (_e) {
            resolve(false);
          }
        });
      } catch (_e2) {
        resolve(false);
      }
    });
  }

  function pGetSubject(item) {
    return new Promise(function (resolve) {
      try {
        if (!item || !item.subject || typeof item.subject.getAsync !== "function") return resolve("");
        item.subject.getAsync(function (result) {
          try {
            if (!result || result.status !== Office.AsyncResultStatus.Succeeded) return resolve("");
            resolve(normalizeString(result.value));
          } catch (_e) {
            resolve("");
          }
        });
      } catch (_e2) {
        resolve("");
      }
    });
  }

  function pGetBodyText(item) {
    return new Promise(function (resolve) {
      try {
        if (!item || !item.body || typeof item.body.getAsync !== "function") return resolve("");
        item.body.getAsync(Office.CoercionType.Text, function (result) {
          try {
            if (!result || result.status !== Office.AsyncResultStatus.Succeeded) return resolve("");
            resolve(normalizeString(result.value));
          } catch (_e) {
            resolve("");
          }
        });
      } catch (_e2) {
        resolve("");
      }
    });
  }

  function escapeHtml(text) {
    return String(text || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function pPrependBody(item, text, asHtml) {
    return new Promise(function (resolve) {
      try {
        if (!item || !item.body || typeof item.body.prependAsync !== "function") return resolve(false);
        var options = { coercionType: asHtml ? Office.CoercionType.Html : Office.CoercionType.Text };
        item.body.prependAsync(text, options, function (result) {
          try {
            resolve(!!result && result.status === Office.AsyncResultStatus.Succeeded);
          } catch (_e) {
            resolve(false);
          }
        });
      } catch (_e2) {
        resolve(false);
      }
    });
  }

  function pAppendBody(item, text, asHtml) {
    return new Promise(function (resolve) {
      try {
        if (!item || !item.body || typeof item.body.appendAsync !== "function") return resolve(false);
        var options = { coercionType: asHtml ? Office.CoercionType.Html : Office.CoercionType.Text };
        item.body.appendAsync(text, options, function (result) {
          try {
            resolve(!!result && result.status === Office.AsyncResultStatus.Succeeded);
          } catch (_e) {
            resolve(false);
          }
        });
      } catch (_e2) {
        resolve(false);
      }
    });
  }

  function pGetBodyType(item) {
    return new Promise(function (resolve) {
      try {
        if (!item || !item.body || typeof item.body.getTypeAsync !== "function") return resolve("text");
        item.body.getTypeAsync(function (result) {
          try {
            if (!result || result.status !== Office.AsyncResultStatus.Succeeded) return resolve("text");
            var t = String(result.value || "").toLowerCase();
            resolve(t);
          } catch (_e) {
            resolve("text");
          }
        });
      } catch (_e2) {
        resolve("text");
      }
    });
  }

  function applyAutoAddMessagePreviewToText(bodyText, autoAddMessage) {
    var out = String(bodyText || "");
    if (!autoAddMessage) return out;
    if (autoAddMessage.isAddToStart && normalizeString(autoAddMessage.messageOfAddToStart)) {
      out = normalizeString(autoAddMessage.messageOfAddToStart) + "\n\n" + out;
    }
    if (autoAddMessage.isAddToEnd && normalizeString(autoAddMessage.messageOfAddToEnd)) {
      out = out + "\n\n" + normalizeString(autoAddMessage.messageOfAddToEnd);
    }
    return out;
  }

  async function buildSnapshot(item, settings, timeoutMs) {
    var displayLanguage = "";
    try {
      displayLanguage = normalizeString(Office.context && Office.context.displayLanguage);
    } catch (_e) {}

    var senderEmail = "";
    try {
      senderEmail = normalizeString(
        Office.context &&
          Office.context.mailbox &&
          Office.context.mailbox.userProfile &&
          Office.context.mailbox.userProfile.emailAddress
      );
    } catch (_e2) {}

    var itemType = "";
    try {
      itemType = normalizeString(item && item.itemType);
    } catch (_e3) {}

    // Recipients
    var to = [];
    var cc = [];
    var bcc = [];

    if (lower(itemType) === "appointment") {
      var required = await withTimeout(pGetRecipients(item.requiredAttendees), timeoutMs, []);
      var optional = await withTimeout(pGetRecipients(item.optionalAttendees), timeoutMs, []);
      to = required;
      cc = optional;
      bcc = [];
    } else {
      to = await withTimeout(pGetRecipients(item.to), timeoutMs, []);
      cc = await withTimeout(pGetRecipients(item.cc), timeoutMs, []);
      bcc = await withTimeout(pGetRecipients(item.bcc), timeoutMs, []);
    }

    var subject = await withTimeout(pGetSubject(item), timeoutMs, "");
    var bodyTextRaw = await withTimeout(pGetBodyText(item), timeoutMs, "");
    var bodyTextForChecks = bodyTextRaw;

    // Add auto-add message text to the evaluation text (OutlookOkan preview behavior)
    try {
      bodyTextForChecks = applyAutoAddMessagePreviewToText(bodyTextRaw, settings && settings.autoAddMessage);
    } catch (_e4) {}

    // Attachments metadata
    var attachments = [];
    try {
      attachments = Array.isArray(item.attachments) ? item.attachments : [];
    } catch (_e5) {
      attachments = [];
    }

    var snap = {
      displayLanguage: displayLanguage,
      senderEmailAddress: senderEmail,
      itemType: itemType,
      subject: subject,
      bodyText: bodyTextForChecks,
      bodyTextRaw: bodyTextRaw,
      recipients: { to: to, cc: cc, bcc: bcc },
      attachments: attachments,
    };

    try {
      await enrichSnapshotWithEws(snap, settings, timeoutMs);
    } catch (_e6) {}

    return snap;
  }

  function sameEmailLists(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (lower(a[i]) !== lower(b[i])) return false;
    }
    return true;
  }

  async function applyRecipientMutations(item, itemType, mutations, timeoutMs) {
    if (!mutations) return;

    var toEmails = Array.isArray(mutations.to) ? mutations.to : [];
    var ccEmails = Array.isArray(mutations.cc) ? mutations.cc : [];
    var bccEmails = Array.isArray(mutations.bcc) ? mutations.bcc : [];

    if (lower(itemType) === "appointment") {
      await withTimeout(pSetRecipients(item.requiredAttendees, toEmails), timeoutMs, false);
      await withTimeout(pSetRecipients(item.optionalAttendees, ccEmails), timeoutMs, false);
      return;
    }

    await withTimeout(pSetRecipients(item.to, toEmails), timeoutMs, false);
    await withTimeout(pSetRecipients(item.cc, ccEmails), timeoutMs, false);
    await withTimeout(pSetRecipients(item.bcc, bccEmails), timeoutMs, false);
  }

  async function applyAutoAddMessageToBody(item, settings, snapshot, timeoutMs) {
    if (!item || !settings || !settings.autoAddMessage) return;
    if (lower(snapshot.itemType) === "appointment") return;

    var autoAdd = settings.autoAddMessage;
    var startMsg = normalizeString(autoAdd.messageOfAddToStart);
    var endMsg = normalizeString(autoAdd.messageOfAddToEnd);
    var bodyText = normalizeString(snapshot.bodyTextRaw != null ? snapshot.bodyTextRaw : snapshot.bodyText);

    var bodyType = await withTimeout(pGetBodyType(item), timeoutMs, "text");
    var isHtml = String(bodyType || "").toLowerCase() === "html";

    if (autoAdd.isAddToStart && startMsg) {
      var already = bodyText.indexOf(startMsg) === 0;
      if (!already) {
        var textToInsert = isHtml ? "<div>" + escapeHtml(startMsg).replace(/\r?\n/g, "<br>") + "</div><br>" : startMsg + "\n\n";
        await withTimeout(pPrependBody(item, textToInsert, isHtml), timeoutMs, false);
      }
    }

    if (autoAdd.isAddToEnd && endMsg) {
      var alreadyEnd = bodyText.lastIndexOf(endMsg) === bodyText.length - endMsg.length;
      if (!alreadyEnd) {
        var textToAppend = isHtml ? "<br><div>" + escapeHtml(endMsg).replace(/\r?\n/g, "<br>") + "</div>" : "\n\n" + endMsg;
        await withTimeout(pAppendBody(item, textToAppend, isHtml), timeoutMs, false);
      }
    }
  }

  function buildSmartAlertMessage(result) {
    var locale = (result && result.locale) || "en-US";
    var ja = startsWith(lower(locale), "ja");
    var cl = result && result.checkList ? result.checkList : null;
    if (!cl) return ja ? "確認が必要です。" : "Review required.";

    if (cl.isCanNotSendMail) {
      return normalizeString(cl.canNotSendMailMessage) || (ja ? "送信禁止です。" : "Send blocked.");
    }

    var lines = [];
    lines.push(ja ? "送信前に確認してください。" : "Please review before sending.");

    try {
      var ext = [];
      function addExt(list, label) {
        for (var i = 0; i < list.length; i++) {
          if (list[i].isExternal) ext.push(label + ": " + list[i].mailAddress);
        }
      }
      addExt(cl.toAddresses || [], "To");
      addExt(cl.ccAddresses || [], "Cc");
      addExt(cl.bccAddresses || [], "Bcc");
      if (ext.length > 0) {
        lines.push((ja ? "外部宛先" : "External recipients") + ": " + ext.length);
        lines = lines.concat(ext.slice(0, 6));
        if (ext.length > 6) lines.push("...");
      }
    } catch (_e) {}

    try {
      var atts = cl.attachments || [];
      if (atts.length > 0) {
        lines.push((ja ? "添付" : "Attachments") + ": " + atts.length);
        for (var i2 = 0; i2 < Math.min(6, atts.length); i2++) {
          lines.push("- " + atts[i2].fileName);
        }
        if (atts.length > 6) lines.push("...");
      }
    } catch (_e2) {}

    try {
      var alerts = (cl.alerts || []).filter(function (a) {
        return a && a.isImportant && !a.isChecked;
      });
      if (alerts.length > 0) {
        lines.push(ja ? "警告:" : "Warnings:");
        for (var i3 = 0; i3 < Math.min(5, alerts.length); i3++) {
          lines.push("- " + alerts[i3].alertMessage);
        }
        if (alerts.length > 5) lines.push("...");
      }
    } catch (_e3) {}

    lines.push(ja ? "送信しますか？" : "Send anyway?");
    return lines.join("\n");
  }

  function completeAllow(event) {
    try {
      event.completed({ allowEvent: true });
    } catch (_e) {}
  }

  function completeBlock(event, message, promptUser) {
    try {
      var opts = { allowEvent: false, errorMessage: String(message || "") };
      if (promptUser && Office && Office.MailboxEnums && Office.MailboxEnums.SendModeOverride) {
        opts.sendModeOverride = Office.MailboxEnums.SendModeOverride.PromptUser;
      }
      event.completed(opts);
    } catch (_e) {
      try {
        event.completed({ allowEvent: false });
      } catch (_e2) {}
    }
  }

  async function messageOnSent(event) {
    if (!event || typeof event.completed !== "function") return;

    var item = null;
    try {
      item = Office.context && Office.context.mailbox && Office.context.mailbox.item;
    } catch (_e) {}
    if (!item) return completeAllow(event);

    var settings = null;
    try {
      if (ns.settings && typeof ns.settings.load === "function") {
        settings = await ns.settings.load();
      }
    } catch (_e2) {
      settings = null;
    }
    if (!settings && ns.settings && typeof ns.settings.defaults === "function") {
      try {
        settings = ns.settings.defaults();
      } catch (_e3) {}
    }
    if (!settings) settings = {};

    var timeoutMs = 4500;
    try {
      if (settings.runtime && typeof settings.runtime.sendEventTimeoutMs === "number") {
        timeoutMs = settings.runtime.sendEventTimeoutMs;
      }
    } catch (_e4) {}

    try {
      var snapshot = await buildSnapshot(item, settings, timeoutMs);
      var result = ns.engine && typeof ns.engine.evaluate === "function" ? ns.engine.evaluate(snapshot, settings) : null;
      if (!result || !result.checkList) {
        return completeBlock(
          event,
          "Mail Checker failed to evaluate the message. Please try again.",
          true
        );
      }

      // Apply mutations (recipients)
      await applyRecipientMutations(item, snapshot.itemType, result.mutations, timeoutMs);

      // Apply auto-add message to actual body (best-effort)
      await applyAutoAddMessageToBody(item, settings, snapshot, timeoutMs);

      if (result.checkList.isCanNotSendMail) {
        return completeBlock(event, result.checkList.canNotSendMailMessage || "Send blocked.", false);
      }

      if (result.showConfirmation) {
        return completeBlock(event, buildSmartAlertMessage(result), true);
      }

      return completeAllow(event);
    } catch (_err) {
      return completeBlock(
        event,
        "Mail Checker failed to run checks due to an unexpected error. Send anyway?",
        true
      );
    }
  }

  function registerHandlers() {
    try {
      if (typeof Office === "undefined") return;
      if (Office.actions && typeof Office.actions.associate === "function") {
        Office.actions.associate("messageOnSent", messageOnSent);
      }
    } catch (_e) {}
  }

  try {
    if (typeof Office !== "undefined" && Office.onReady && typeof Office.onReady === "function") {
      Office.onReady(registerHandlers);
    } else {
      registerHandlers();
    }
  } catch (_e) {
    registerHandlers();
  }
})();
